# Yandex / Хендбуки / Основы Python
# 3.1. Строки, кортежи, списки


def p_3_1_a():
    """
    Малыши начали учить алфавит. Воспитатель попросил их
    назвать слова, начинающиеся только с букв А, Б или В.
    Напишите программу, которая проверит, что все введённые слова
    соответствуют этим правилам.

    Формат ввода
    Вводится натуральное число N — количество слов, названных детьми.
    В каждой из последующих N строк записано по одному слову строчными буквам.

    Формат вывода
    YES — если все слова начинаются с нужной буквы.
    NO — если хотя бы одно слово начинается не с нужной буквы.
    """
    print(
        "YES" if all(input().lower()[0] in "абв" for _ in range(int(input()))) else "NO"
    )


def p_3_1_b():
    """
    Иногда в текстовых редакторах возникает необходимость повернуть
    строку — то есть сделать из горизонтальной записи вертикальную.
    В Python такая функция по-умолчанию отсутствует, но это не проблема:
    мы напишем её сами!
    Напишите программу, которая преобразует введённую стоку
    из горизонтальной записи в вертикальную.

    Формат ввода Одна строка.

    Формат вывода Вертикальное представление введённой строки.
    """
    for ch in input():
        print(ch)


def p_3_1_с():
    """
    Когда вы работаете со строками, часто приходится управлять
    их длиной — особенно в реальных проектах: сайтах, приложениях, чат-ботах.
    В этой задаче вы выступите в роли разработчика новостного сайта.
    Местная редакция заказала у вас систему для отображения заголовков.
    Чтобы лента была удобной, слишком длинные заголовки нужно сокращать
    и добавлять многоточие.
    Напишите программу, которая сокращает заголовки до требуемой длины.
    Если заголовок длиннее, он должен быть усечён и завершён многоточием ....
    Если заголовок помещается в заданную длину — выводите его без изменений.

    Формат ввода
    Вводится натуральное число L — необходимая длина заголовка.
    Вводится натуральное число N — количество заголовков,
    которые требуется сократить.
    В каждой из последующих N строк записано по одному заголовку.

    Формат вывода Сокращённые заголовки.
    """
    title_len = int(input())
    for _ in range(int(input())):
        full_title = input()
        print(
            full_title
            if len(full_title) <= title_len
            else full_title[: title_len - 3] + "..."
        )


def p_3_1_d():
    """
    Работая с реальными текстовыми файлами и логами, почти всегда приходится
    сталкиваться с «грязными» данными: лишними символами, мусорными строками,
    ошибками форматирования.
    В этой задаче вы поможете местному провайдеру почистить отчёты: устраните
    системные ошибки и оставите только полезную информацию.
    Напишите программу, которая обрабатывает лог-файл, состоящий из строк, и:
    - удаляет две решётки ## в начале строки, если они есть;
    - удаляет всю строку, если она заканчивается на @@@.
    Ввод продолжается, пока не встретится пустая строка.

    Формат ввода
    Вводятся строки отчёта. Признаком завершения ввода считается пустая строка.

    Формат вывода Очищенные данные.
    """
    while s := input():
        if s[-3:] != "@@@":
            print(s.lstrip("##"))


def p_3_1_e():
    """
    Продолжаем исследовать симметричные строки — палиндромы.
    Палиндром — это строка, которая читается одинаково слева
    направо и справа налево. Например: анна, казак, топот.
    А вот мама — уже не палиндром.
    Напишите программу, которая определяет, относится ли
    введённая строка к палиндромам.

    Формат ввода Вводится строка.

    Формат вывода Требуется вывести YES — если введенная
    строка является палиндромом, иначе – NO.
    """
    s = input()
    print("YES" if s == s[::-1] else "NO")


def p_3_1_f():
    """
    Очередное семейное путешествие — и снова игра
    «Кто первым увидит зверушку за окном».
    Сегодня в фокусе внимания — зайки.
    Поможем ребятам подсчитать, сколько заек они увидели!
    Напишите программу, которая по описаниям местности определяет,
    сколько раз встретилась зайка.

    Формат ввода В первой строке записано натуральное число
    N — количество выделенных придорожных местностей.
    В каждой из N последующих строк записано описание придорожной местности.

    Формат вывода Количество заек.
    """
    print(sum(input().count("зайка") for _ in range(int(input()))))


def p_3_1_g():
    """
    Ввод данных от пользователя не всегда бывает удобным — особенно,
    если речь идёт о строках, в которых содержатся сразу несколько чисел.
    В этой задаче вы потренируетесь извлекать данные из строки
    и преобразовывать их для дальнейших вычислений.
    Ведь даже А и Б из детского стишка порой нуждаются в вычислениях!
    Напишите программу, которая считывает два целых числа,
    введённые в одной строке через пробел, и выводит их сумму.

    Формат ввода Два целых числа, разделённые пробелом.

    Формат вывода Одно целое число — сумма переданных чисел.
    """
    print(sum(map(int, input().split())))


def p_3_1_h():
    """
    Поезд мчится вдоль берёзок, елочек и сосен, а дети за окном снова
    ищут любимых зверушек — заек! На этот раз — задача посложнее:
    нужно не только найти, но и точно указать,
    где именно в строке прячется первый заяц!
    Напишите программу, которая для каждой строки описания местности:
    - выводит позицию первого появления слова зайка (нумерация начинается с 1);
    — если в строке нет зайки — выведите: Заек нет =(.

    Формат ввода В первой строке записано натуральное число
    N — количество выделенных придорожных местностей.
    В каждой из N последующих строк записано описание придорожной местности.

    Формат вывода Для каждой строки нужно найти положение первого зайки.
    Если в строке нет заек, то об этом нужно непременно сообщить.

    Примечание Для символов в строках используйте нумерацию с 1.
    """
    for _ in range(int(input())):
        s = input().find("зайка")
        print(s + 1 if s != -1 else "Заек нет =(")


def p_3_1_i():
    """
    Комментарии — важная часть кода, особенно если вы хотите,
    чтобы другие поняли вашу логику.
    Но когда программа запускается, интерпретатор просто игнорирует
    комментарии — всё, что начинается с #.
    В этой задаче вы сами выступите в роли интерпретатора:
    научитесь очищать строки кода от комментариев!
    Напишите программу, которая удаляет комментарии из кода.
    Если строка состоит только из комментария — её не нужно выводить вообще.

    Формат ввода Вводятся строки программы.
    Признаком остановки является пустая строка.

    Формат вывода Каждую строку нужно очистить от комментариев.
    А если комментарий — вся строка, то выводить её не надо.

    Примечание Символ # в данной задаче используется только для комментариев.
    """
    while s := input():
        sh = s.find("#")
        if sh != 0:
            print(s if sh == -1 else s[:sh])


def p_3_1_j():
    """
    Частотный анализ — это метод подсчёта, какие символы
    (или слова) чаще всего встречаются в тексте.
    Это важнейший инструмент взлома многих классических
    шифров — от шифра Цезаря и до шифровальной машины «Энигма».
    В этой задаче вы реализуете простейшую версию частотного анализа:
    выясните, какая буква встречается чаще других в тексте.
    Напишите программу, которая читает строки до тех пор,
    пока не встретится строка 'ФИНИШ', и выводит наиболее часто
    встречающуюся букву (в нижнем регистре).

    Формат ввода Вводятся строки, пока не будет введена строка «ФИНИШ».

    Формат вывода Выводится один символ в нижнем регистре — наиболее
    часто встречающийся во введённой строке.

    Примечания Пробелы в анализе не участвуют.
    Если в результате анализа получено несколько ответов,
    следует вывести первый по алфавиту.

    У данной задачи множество "быстрых" способов решения, но в этом параграфе
    мы просим вас сосредоточиться на использовании строк и списков.
    """
    text = ""
    while (s := input()) != "ФИНИШ":
        text += s.lower().replace(" ", "")
    result_ch = ""
    max_count = 0
    for ch in sorted(list(set(text))):
        ch_count = text.count(ch)
        if ch_count > max_count:
            result_ch, max_count = ch, ch_count
    print(result_ch.lower())


def p_3_1_k():
    """
    Поиск информации — одна из самых важных задач в наше время.
    Предлагаем потренироваться в работе со списками строк,
    поиском подстроки, и игнорированием регистра.
    Создайте мини-поисковик, который по ключевому слову покажет
    подходящие заголовки страниц.

    Формат ввода Вводится натуральное число
    N — количество страниц, среди которых требуется произвести поиск.
    В каждой из последующих N строк записаны заголовки страниц.
    В последней строке записан поисковый запрос.

    Формат вывода Вывести все заголовки страниц, в которых присутствует
    поисковый запрос (регистр не имеет значения).
    Порядок заголовков должен сохраниться.
    """
    headers = [input() for _ in range(int(input()))]
    query = input().lower()
    for header in headers:
        if query in header.lower():
            print(header)


def p_3_1_l():
    """
    В детском саду ежедневно подают новую кашу на завтрак.
    Каши чередуются в следующем порядке:
    Манная; Гречневая; Пшённая; Овсяная; Рисовая.
    Ваша задача — составить расписание каш на ближайшие дни,
    чтобы повара знали, что готовить.
    Напишите программу, которая по числу дней N выводит,
    какие каши будут подаваться в ближайшие N дней.

    Формат ввода Вводится натуральное число N — количество дней.

    Формат вывода     Вывести список каш в порядке подачи.
    """
    n = int(input())
    porridges = ["Манная", "Гречневая", "Пшённая", "Овсяная", "Рисовая"]
    print(*(porridges * (n // 5 + 1))[:n], sep="\n")


def p_3_1_m():
    """
    Часто возникают трудности, когда нужно выполнить множество
    однообразных операций. В таких случаях люди желают упростить
    себе работу. Напишите программу, которая возводит в заданную
    степень все числа, что передали пользователи.

    Формат ввода Вводится натуральное число N — количество чисел.
    В каждой из последующих N строк записано по одному числу.
    В последней строке записано натуральное число
    P — степень, в которую требуется возвести числа.

    Формат вывода
    Последовательность чисел, являющихся ответом.
    """
    nums = [int(input()) for _ in range(int(input()))]
    power = int(input())
    print(*map(lambda x: x**power, nums), sep="\n")


def p_3_1_n():
    """
    Иногда приходится выполнять однотипные действия над целой группой
    чисел — например, возвести каждое из них в заданную степень.
    Вручную это делать долго и утомительно, особенно если чисел много.
    Пора автоматизировать процесс!
    Напишите программу, которая возводит в заданную степень все числа,
    переданные пользователем.

    Формат ввода
    В первой строке записана последовательность натуральных чисел,
    разделённых пробелами. Во второй строке записано натуральное число
    P — степень, в которую требуется возвести числа.

    Формат вывода Последовательность чисел, являющихся ответом.
    Числа вывести в одну строку через пробел.
    """
    nums = map(int, input().split())
    power = int(input())
    print(*map(lambda x: x**power, nums))


def p_3_1_o():
    """
    Из местного НИИ снова обратились за помощью. Им снова нужно находить
    наибольший общий делитель (НОД) — теперь по целой строке чисел.
    Хорошо, что у нас есть опыт! Напишите программу, которая находит НОД
    всех чисел, введённых в одной строке через пробел.

    Формат ввода В единственной строке записывается последовательность
    натуральных чисел, разделённых пробелами.

    Формат вывода Требуется вывести одно натуральное
    число — НОД всех данных чисел.

    Примечание Самый распространенный способ поиска НОД — Алгоритм Эвклида.
    """
    nums = list(map(int, input().split()))
    div = nums[-1]
    for num in nums:
        while num:
            div, num = num, div % num
    print(div)


def p_3_1_p():
    """
    Вы снова работаете над лентой новостей для сайта.
    Теперь заголовки могут занимать несколько строк, но при этом всё равно
    нужно соблюдать лимит: если заголовок слишком длинный — он должен быть
    сокращён и завершён многоточием .... Эта задача поможет вам научиться
    учитывать длину строк, переносы и условия обрезки текста.
    Напишите программу, которая по заданному количеству строк и максимально
    допустимой длине:
    - выводит заголовок, при необходимости обрезая его;
    - если заголовок слишком длинный — заменяет последние символы на ...;
    - если строки заканчиваются слишком коротко, ... может перейти
      в предыдущую строку.

    Формат ввода Вводится натуральное число L — необходимая длина заголовка.
    Вводится натуральное число N — количество строк в заголовке новости.
    В каждой из последующих N строк записано по одной строке заголовка.

    Формат вывода Сокращённый заголовок.

    Примечание Многоточие учитывается при подсчёте длины заголовка.
    Символ перевода строки при подсчёте длины не учитывается.
    """
    header_len = int(input())
    text = [input() for _ in range(int(input()))]
    res = ""
    for row in text:
        if header_len - len(row) > 3:
            res += row + "\n"
            header_len -= len(row)
        else:
            res += row[: header_len - 3] + "..."
            break
    print(res)


def p_3_1_q():
    """
    Мы снова возвращаемся к загадочным палиндромам — на этот раз с небольшим
    усложнением. Теперь нужно определить, является ли строка палиндромом без
    учёта регистра и пробелов. То есть А роза упала на лапу Азора — это
    палиндром, а Мама мыла раму — уже нет. Напишите программу, которая
    проверяет, является ли введённая строка палиндромом.

    Формат ввода Вводится строка.

    Формат вывода Если введённая строка относится к палиндрому,
    то вывести YES, а иначе — NO.

    Примечание При проверке не обращайте внимания на регистр и пробелы.
    """
    s = input().lower().strip().replace(" ", "")
    print("YES" if s == s[::-1] else "NO")


def p_3_1_r():
    """
    RLE (Run-Length Encoding) — это способ сокращённой записи повторяющихся
    символов. Вместо длинной группы одинаковых символов записывается сам
    символ и число его повторений.
    Например, 99999 превращается в 9 5 («девять пять раз»). Напишите программу,
    которая получает строку из цифр и выводит её RLE-представление:
    последовательность пар «цифра — количество подряд идущих повторений».

    Формат ввода Строка цифр длиной не меньше 1.

    Формат вывода Пары: сама цифра и количество повторений цифры подряд
    во введённой строке, как описано в условии и показано в примере.
    """
    nums = input()
    counter = 1
    for i, num in enumerate(nums):
        if i + 1 < len(nums) and nums[i + 1] == num:
            counter += 1
        else:
            print(num, counter)
            counter = 1


def p_3_1_s():
    """
    Сейчас — вызов на логику: реализуем калькулятор на основе обратной
    польской нотации (ОПН). В ОПН нет скобок и приоритета операций — всё
    вычисляется строго слева направо, с помощью стека. Вы добавляете числа
    в стек, а когда встречаете оператор (+, -, *) — извлекаете два последних
    числа, применяете операцию и возвращаете результат обратно в стек.
    Напишите программу, которая по введённому выражению в ОПН
    вычисляет результат.

    Формат ввода Вводится одна строка, содержащая разделённые пробелами
    целые числа и знаки операций +, -, *, которые вместе составляют корректное
    выражение в обратной польской нотации.

    Формат вывода Выводится одно целое число — результат вычисления выражения.

    7 2 3 * - читается так:

    7 помещается в стек
    2 помещается в стек
    3 помещается в стек
    2 и 3 извлекаются из стека и над ними производится операция умножения,
    а результат 6 помещается в стек
    7 и 6 извлекаются из стека и над ними производится операция вычитания,
    а результат 1 помещается в стек
    В конце выполнения в стеке остаётся ровно одно число — это
    и есть результат.
    """
    # важно не перепутать правый и левый аргументы
    data = input().split()
    s = []
    for d in data:
        if d in "+-*":
            b = s.pop()
            a = s.pop()
            if d == "+":
                s.append(a + b)
            elif d == "-":
                s.append(a - b)
            elif d == "*":
                s.append(a * b)
        else:
            s.append(int(d))
    print(s[0])


def p_3_1_t():
    """
    Напоследок последняя задача с ОПН. Операции, которые выполняются с одним
    значением, называются унарными, с двумя — бинарными, с тремя — тернарными.
    Давайте улучшим наш калькулятор, добавив поддержку следующих операций:
        бинарные:
            + (сложение),
            - (вычитание),
            * (умножение),
            / (деление нацело; для отрицательных чисел
                по тем же правилам, что и в Python);
        унарные:
         ~ (унарный минус — меняет знак),
            ! (факториал),
            # (клонирование — вернуть в стек значение дважды);
        тернарные:
            @ (возвращает в стек те же три значения,
                но в ином порядке: второе, третье, первое).
    Формат ввода Вводится одна строка, содержащая разделённые пробелами
    целые числа и знаки операций. Вместе они составляют корректное выражение
    в обратной польской нотации, не содержащее деления на ноль и взятия
    факториала от отрицательного числа.

    Формат вывода Выводится одно целое число — результат вычисления выражения.
    """
    # если бы я не знала заранее про стеки,
    # догадаться до алгоритма работы с переменными было крайне сложно
    data = input().split()
    s = []

    for d in data:
        match d:
            case "+":
                b = s.pop()
                a = s.pop()
                s.append(a + b)
            case "-":
                b = s.pop()
                a = s.pop()
                s.append(a - b)
            case "*":
                b = s.pop()
                a = s.pop()
                s.append(a * b)
            case "/":
                b = s.pop()
                a = s.pop()
                s.append(a // b)
            case "~":
                a = s.pop()
                s.append(-a)
            case "!":
                a = s.pop()
                acc = 1
                for i in range(1, a + 1):
                    acc *= i
                s.append(acc)
            case "#":
                s.append(s[-1])
            case "@":
                c = s.pop()
                b = s.pop()
                a = s.pop()
                s.extend([b, c, a])
            case _:
                s.append(int(d))
    print(s[0])
