# Yandex / Хендбуки / Основы Python
# 4.2. Позиционные и именованные аргументы.
# Функции высших порядков. Лямбда-функции

from functools import reduce


def p_4_2_a():
    """
    Большинство задач этого параграфа направлены на отработку навыков
    написания функций. Напишите функцию make_list, которая возвращает
    список заданной длины, заполненный переданным значением.
    Параметры функции:
    — length — длина списка;
    — value — значение, которым нужно заполнить список (по умолчанию 0).
    Ваше решение будет использоваться как библиотека.
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """


def make_list(length, value=0):
    return [value] * length


# print(make_list(3) == [0, 0, 0], make_list(5, 1) == [1, 1, 1, 1, 1])


def p_4_2_b():
    """
    Напишите функцию make_matrix, которая создаёт, заполняет и
    возвращает матрицу заданного размера. Параметры функции:
    — size — кортеж (ширина, высота) или одно число
      (для создания квадратной матрицы);
    — value — значение элементов списка (по-умолчанию 0).
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """
    # в задании есть проверка использование одного объекта вместо генерации

    def make_matrix(size, value=0):
        if type(size) is int:
            size = (size, size)
        col, row = size
        return [[value] * col for _ in range(row)]

    """print(
        make_matrix(3) == [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
        make_matrix((4, 2), 1) == [[1, 1, 1, 1], [1, 1, 1, 1]],
    )
    """


def p_4_2_с():
    """
    Напишите функцию gcd, которая вычисляет наибольший общий
    делитель последовательности чисел. Параметрами функции
    выступают натуральные числа в произвольном количестве,
    но не менее одного.
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    def gcd(*args):
        gcd = max(args)
        for a in args:
            a, b = sorted((a, gcd))
            while a:
                a, b = b % a, a
            gcd = b
        return gcd

    # print(gcd(3) == 3, gcd(36, 48, 156, 100500) == 12)


def p_4_2_d():
    """
    Разработайте функцию month, которая возвращает название заданного
    месяца с заглавной буквы. Функция должна принимать номер месяца и
    дополнительно обозначение языка (по умолчанию "ru").
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """


def month(number, language="ru"):
    transtare = {
        "ru": [
            "Январь",
            "Февраль",
            "Март",
            "Апрель",
            "Май",
            "Июнь",
            "Июль",
            "Август",
            "Сентябрь",
            "Октябрь",
            "Ноябрь",
            "Декабрь",
        ],
        "en": [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
        ],
    }
    return transtare[language][number - 1]


# print(month(1, "en") == "January", month(7) == "Июль")


def p_4_2_e():
    """
    Напишите функцию to_string, которая формирует из последовательности
    данных строку. Функция должна принимать:
    — неопределённое количество данных;
    — необязательный параметр sep (по умолчанию пробел);
    — необязательный параметр end (по умолчанию \n).
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    def to_string(*args, sep=" ", end="\n"):
        return sep.join(map(str, args)) + end

    """print(to_string(1, 2, 3) == "1 2 3\n")
    data = [7, 3, 1, "hello", (1, 2, 3)]
    print(to_string(*data, sep=", ", end="!") == "7, 3, 1, hello, (1, 2, 3)!")"""


def p_4_2_f():
    """
    Разработайте функцию get_operator, которая принимает строковое
    обозначение одной из целочисленных математических операций
    Python (+, -, *, //, **) и возвращает соответствующую функцию
    двух переменных.
    Примечание В решении не должно быть вызовов требуемых функций.
    """

    def get_operator(operator):
        operations = {
            "+": lambda x, y: x + y,
            "-": lambda x, y: x - y,
            "*": lambda x, y: x * y,
            "//": lambda x, y: x // y,
            "**": lambda x, y: x**y,
        }
        return operations[operator]

    """operator_plus = get_operator("+")
    print(operator_plus(3, 5) == 8)
    operator_power = get_operator("**")
    print(operator_power(2, 10) == 1024)"""


def p_4_2_g():
    """
    Напишите функцию get_formatter, которая принимает два
    именованных параметра:
    — sep – разделитель, по умолчанию пробел;
    — end - завершающий символ, по умолчанию пустая строка.
    Функция должна вернуть новую функцию, которая преобразует
    не определенное количество аргументов в строку, с заданным
    ранее разделителем и завершающим символом.
    Примечание В решении не должно быть вызовов требуемых функций.
    """

    def get_formatter(sep=" ", end=""):
        return lambda *args: sep.join(str(a) for a in args) + end

    """formatter = get_formatter()
    print(formatter(1, 2, 3, 4, 5) == "1 2 3 4 5")
    formatter = get_formatter(end="!", sep=", ")
    print(formatter("Hello", "world") == "Hello, world!")"""


def p_4_2_h():
    """
    Напишите функцию grow, принимающую, неопределенное количество
    позиционных и именованных параметров. Для каждого именованного
    параметра, требуется найти все позиционные, кратные длине его
    названия, а затем увеличить их на его значение.
    Результатом функции должен, являться кортеж преобразованных
    позиционных параметров.
    Примечание В решении не должно быть вызовов требуемых функций.
    """

    def grow(*args, **kwargs):
        nums = list(args)
        for k, v in kwargs.items():
            for i, num in enumerate(args):
                if num % len(k) == 0:
                    nums[i] += v
        return tuple(nums)

    """print(
        grow(1, 2, 3, 4, 5, ab=7, dad=10) == (1, 9, 13, 11, 5),
        grow(12, 5, 30, 60, 15, first=13, second=2, Bob=7) == (21, 18, 52, 82, 35),
    )"""


def p_4_2_i():
    """
    Напишите функцию product, принимающую, неопределенное
    количество позиционных и именованных параметров.
    Каждую строку, переданную в качестве позиционного параметра,
    функция должна заменить на произведение значений именованных
    параметров, которые встретились в ней.
    Результатом функции должен являться кортеж полученных чисел.
    Если для строки не нашлось именованных параметров,
    то и в результатах она должна отсутствовать.
    Примечание В решении не должно быть вызовов требуемых функций.
    """

    # from functools import reduce

    def product(*args, **kwargs):
        result = []
        for word in args:
            nums = [kwargs[ch] for ch in set(word) if ch in kwargs]
            if nums:
                result.append(reduce(lambda acc, x: acc * x, nums, 1))
        return tuple(result)

    """print(
        product("Ann", "Bob", A=2, n=7, b=3) == (14, 3),
        product("Ann", "Bob", "Chuck", a=9, n=5, u=3, c=2, A=5) == (25, 6),
    )
    """


def p_4_2_j():
    """
    Напишите функцию choice, принимающую, неопределенное количество
    целых чисел, а также один из именованных параметров: min или max.
    В качестве именованных параметров вам будут предоставлены функции.
    Если был, передан параметр min, ваша функция должна вернуть
    минимальный из результатов применения переданной функции
    к позиционным аргументам. Если же, передан max – максимальный.
    Примечание В решении не должно быть вызовов требуемых функций.
    """

    def choice(*args, **kwargs):
        key, func = next(iter(kwargs.items()))
        nums = [func(a) for a in args]
        return min(nums) if key == "min" else max(nums)

    """print(
        choice(1, 2, 3, 4, 5, max=lambda x: 2**x) == 32,
        choice(321, 87, 1000, -23, min=lambda x: len(str(x))) == 2,
    )"""


def p_4_2_k():
    """
    Руководство местной кофейни для программистов под названием
    Java-0x00 решило модернизировать систему заказа кофе.
    Для этого им требуется реализовать функцию order, которая
    принимает список предпочтений посетителя в порядке «убывания желания».
    Согласно положению, каждый напиток в кофейне строго определён рецептом:
    — Эспрессо готовится из: 1 порции кофейных зерен.
    — Капучино готовится из: 1 порции кофейных зерен и 3 порций молока.
    — Макиато готовится из: 2 порций кофейных зерен и 1 порции молока.
    — Кофе по-венски готовится из: 1 порции кофейных зерен
      и 2 порций взбитых сливок.
    — Латте Макиато готовится из: 1 порции кофейных зерен, 2 порций молока
      и 1 порции взбитых сливок.
    — Кон Панна готовится из: 1 порции кофейных зерен
      и 1 порции взбитых сливок.
    В глобальной переменной in_stock содержится словарь,
    описывающий ингредиенты в наличии. Ключи словаря: coffee, cream, milk.

    Функция должна вернуть:
    — название напитка, который будет приготовлен;
    — сообщение «К сожалению, не можем предложить Вам напиток»,
    если ни одно из предпочтений не может быть приготовлено.
    Если заказ, может быть совершён, количество доступных
    ингредиентов должно соответствующим образом уменьшиться.

    Примечание В решении не должно быть вызовов требуемых функций.
    """

    menu = {
        "Эспрессо": {"coffee": 1},
        "Капучино": {"coffee": 1, "milk": 3},
        "Макиато": {"coffee": 2, "milk": 1},
        "Кофе по-венски": {"coffee": 1, "cream": 2},
        "Латте Макиато": {"coffee": 1, "milk": 2, "cream": 1},
        "Кон Панна": {"coffee": 1, "cream": 1},
    }

    def order(*args):
        global in_stock
        for drink in args:
            if all(
                in_stock[ingredient] >= count
                for ingredient, count in menu[drink].items()
            ):
                for ingredient, count in menu[drink].items():
                    in_stock[ingredient] -= count
                return drink
        return "К сожалению, не можем предложить Вам напиток"

    # in_stock = {"coffee": 1, "milk": 2, "cream": 3}
    """print(
        order(
            "Эспрессо",
            "Капучино",
            "Макиато",
            "Кофе по-венски",
            "Латте Макиато",
            "Кон Панна",
        )
        == "Эспрессо"
    )
    print(
        order(
            "Эспрессо",
            "Капучино",
            "Макиато",
            "Кофе по-венски",
            "Латте Макиато",
            "Кон Панна",
        )
        == "К сожалению, не можем предложить Вам напиток"
    )"""

    # in_stock = {"coffee": 4, "milk": 4, "cream": 0}
    """
    print(order("Капучино", "Макиато", "Эспрессо") == "Капучино")
    print(order("Капучино", "Макиато", "Эспрессо") == "Макиато")
    print(order("Капучино", "Макиато", "Эспрессо") == "Эспрессо")
    """


def p_4_2_l():
    """
    Лаборанты проводят эксперимент и запросили разработку системы
    обработки данных. Результатами эксперимента должны стать пары
    рациональных чисел. Для работы им требуются функции:
    — enter_results(first, second, ...) — добавление данных одного
      или нескольких результатов (гарантируется, что количество
      параметров будет чётным);
    — get_sum() — возвращает пару сумм результатов экспериментов;
    — get_average() — возвращает пару средних арифметических
      значений результатов экспериментов.
    Все вычисления производятся с точностью до сотых.
    Примечание В решении не должно быть вызовов требуемых функций.
    """

    results = []

    def enter_results(*args):
        results.extend(args)

    def get_sum():
        sum1 = round(sum(num for num in results[::2]), 2)
        sum2 = round(sum(num for num in results[1::2]), 2)
        return (sum1, sum2)

    def get_average():
        count = len(results) / 2
        avr1 = round(sum(num for num in results[::2]) / count, 2)
        avr2 = round(sum(num for num in results[1::2]) / count, 2)
        return (avr1, avr2)

    """ test 1
    enter_results(1, 2, 3, 4, 5, 6)
    print(get_sum(), get_average())  # (9, 12) (3.0, 4.0)
    enter_results(1, 2)
    print(get_sum(), get_average())  # (10, 14) (2.5, 3.5)"""

    """ test 2
    enter_results(3.5, 2.14, 45.2, 37.99)
    print(get_sum(), get_average())  # (48.7, 40.13) (24.35, 20.07)
    enter_results(5.2, 7.3)
    print(get_sum(), get_average())  # (53.9, 47.43) (17.97, 15.81)
    enter_results(1.23, 4.56, 3.14, 2.71, 0, 0)
    print(get_sum(), get_average())  # (58.27, 54.7) (9.71, 9.12)"""


def p_4_2_m():
    """
    Напишите lambda выражение для сортировки списка слов сначала
    по длине, а затем по алфавиту без учёта регистра.
    Примечание В решении не должно быть ничего, кроме выражения.
    """

    lambda word: (len(word), word.lower())

    """string = "мама мыла раму"
    print(sorted(string.split(), key=result) == ["мама", "мыла", "раму"])

    string = "Яндекс использует Python во многих проектах"
    print(
        sorted(string.split(), key=result)
        == ["во", "Python", "многих", "Яндекс", "проектах", "использует"]
    )"""


def p_4_2_n():
    """
    Напишите lambda выражение для фильтрации чисел с чётной суммой цифр.
    Примечание В решении не должно быть ничего, кроме выражения.
    """

    lambda num: sum(map(int, str(num))) % 2 == 0

    """
    print(*filter(result, (1, 2, 3, 4, 5)))  # 2 4
    print(*filter(result, (32, 64, 128, 256, 512)))  # 64 512
    """


def p_4_2_o():
    """
    Разработайте функцию get_repeater, которая принимает некую
    функцию func и число count. Результатом работы get_repeater
    должна быть функция, которая выполняет действие func count раз.
    Примечание В решении не должно быть вызовов требуемых функций.
    """
    # судя по тестам, ИИ, составлявший задачу, умолчал, что функия - редуктор
    # спасибо хоть все функции от 1 переменной

    def get_repeater(func, count):
        def repeat(arg):
            result = arg
            for _ in range(count):
                result = func(result)
            return result

        return repeat

    """
    repeater = get_repeater(lambda x: x + 1, 5)
    print(repeater(2) == 7)
    repeater = get_repeater(lambda x: x * 2, 10)
    print(repeater(1) == 1024)
    """


def p_4_2_p():
    """
    Одной из популярных стратегий в программировании являются
    "коллбэки" (callback). Это функция передаваемая в качестве
    параметра и выполняемая при соблюдении тех или иных условий.
    Напишите функцию login, которая принимает имя пользователя и
    пароль, а также два "коллбэка", первый для реакции на успешную
    авторизацию, а второй - на ошибку. Каждый из "коллбэков" в
    качестве параметра принимает имя пользователя.

    Для проверки правильности пароля следуйте алгоритму:
    — найдите сумму всех кодов символов имени пользователя;
    — умножьте, полученное значение, на длину имени;
    — переведите, переведите полученное значение в 16-ричную систему счисления.
    Полученная в итоге строка, будет соответствовать перевёрнутому паролю.

    Примечание В решении не должно быть вызовов требуемых функций.
    """
    # в задании явно не указан регистр букв, а это важно

    def login(username, password, on_success, on_error):
        check = hex(sum(map(ord, username)) * len(username))[2:].upper()
        if check == password[::-1]:
            on_success(username)
        else:
            on_error(username)


def p_4_2_q():
    """
    Напишите lambda выражение для фильтрации элементов словаря.
    Вам следует оставить только те элементы, в которых значением
    являются списки содержащие хотя бы одно чётное число.
    Примечание В решении не должно быть ничего, кроме выражения.
    """

    lambda row: isinstance(row[1], list) and any(num % 2 == 0 for num in row[1])

    # data = {"first": 2, "second": "2 + 2 = 4", "third": [1, 2, 3]}
    # print(dict(filter(result, data.items())) == {"third": [1, 2, 3]})
    # data = {"first": [7, 2, "1"], "second": (45, 2, 14), "third": [98]}
    # print(dict(filter(result, data.items())) == {"first": [7, 2, "1"], "third": [98]})


def p_4_2_r():
    """
    Напишите lambda выражение для преобразования элементов словаря.
    Все ключи словаря, следует записать в нижнем регистре, удалив
    цифры, пробелы и знаки препинания.
    А все значения, являющиеся итерируемыми, суммировать.
    Примечание В решении не должно быть ничего, кроме выражения.
    """

    lambda row: (
        "".join(ch.lower() for ch in str(row[0]) if ch.isalpha()),
        sum(row[1]) if isinstance(row[1], (list, set, tuple)) else row[1],
    )

    """print(
        dict(map(result, {"First 1": 2, "second:": (2, 1, 1), "THIRD": [1, 2, 3]}.items()))
        == {"first": 2, "second": 4, "third": 6}
    )
    """


def p_4_2_s():
    """
    Вася любит секреты и шифрование. Он часто пользуется шифром
    на основе замен и просит разработать вас функцию, которая
    позволит ему быстро шифровать сообщения.
    Напишите функцию secret_replace, которая принимает:
    — текст требующий шифрования;
    — именованные аргументы — правила замен, представляющие
      собой кортежи из одного или нескольких значений.
    Функция должна вернуть зашифрованный текст.
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    def secret_replace(text, **kwargs):
        counter = dict.fromkeys(kwargs, 0)
        result = ""
        for ch in text:
            if ch in kwargs:
                if len(kwargs[ch]) == 1:
                    num = 0
                else:
                    num = counter[ch] % len(kwargs[ch])
                    counter[ch] += 1
                result += kwargs[ch][num]
            else:
                result += ch
        return result

    """
    print(
        secret_replace("Hello, world!", l=("hi", "y"), o=("123", "z"))
        == "Hehiy123, wzrhid!"
    )
    print(
        secret_replace(
            "ABRA-KADABRA",
            A=("Z", "1", "!"),
            B=("3",),
            R=("X", "7"),
            K=("G", "H"),
            D=("0", "2"),
        )
        == "Z3X1-G!0Z371"
    )
    """


def p_4_2_t():
    """
    База данных — это упорядоченный набор структурированной
    информации или данных, которые обычно хранятся в электронном
    виде в компьютерной системе. База данных обычно управляется
    системой управления базами данных (СУБД). Данные вместе с СУБД,
    а также приложения, которые с ними связаны, называются системой
    баз данных, или, для краткости, просто базой данных.

    Работа с базами данных весьма частое занятие для программиста,
    а также достаточно сложное в реализации.
    Давайте реализуем небольшую пародию на базу данных.
    Напишите функции:
    — insert производящую добавление информацию об одном или
      нескольких пользователях в базу;
    — select производящую выборку всех пользователей на данный
      момент или нескольких подходящих под критерии.
    Критерии для поиска информации задаются в виде строк
    в следующем формате: <имя_поля> <оператор сравнения> <значение>

    Информацию о пользователе будем представлять в виде словаря с ключами:
    — id – уникальный идентификатор пользователя,
      представленный натуральным числом;
    — name – уникальное имя пользователя, представленное строкой.
    — birth – дата рождения в формате DD.MM.YYYY.
    Примечание В решении не должно быть вызовов требуемых функций.
    При выборке пользователи должны быть отсортированы
    по возрастанию идентификатора.
    """

    bd = []

    def data_chek(data: str, kind: str, query: str):
        d_parts = list(map(int, data.split(".")))[::-1]
        q_parts = list(map(int, query.split(".")))[::-1]
        for d, q in zip(d_parts, q_parts):
            if d != q:
                return eval(f"{d} {kind} {q}")
        return eval(f"{d_parts[-1]} {kind} {q_parts[-1]}")

    def insert(*args):
        for row in args:
            bd.append(row)

    def select(*args):
        if not args:
            return bd
        name, kind, value = args[0].split()
        if name == "name":
            filtered = [row for row in bd if eval(f"row['name'] {kind} '{value}'")]
        elif name == "id":
            filtered = [row for row in bd if eval(f"row['id'] {kind} {value}")]
        elif name == "birth":
            filtered = [row for row in bd if data_chek(row["birth"], kind, value)]
        return sorted(filtered, key=lambda row: row["id"])

    """
    insert({"id": 1, "name": "Ann", "birth": "01.03.2001"})
    insert(
        {"id": 3, "name": "Bob", "birth": "05.03.2002"},
        {"id": 4, "name": "Chuck", "birth": "07.06.2001"},
    )
    print([user["name"] for user in select()] == ["Ann", "Bob", "Chuck"])
    print([user["name"] for user in select("name > B")] == ["Bob", "Chuck"])
    insert({"id": 2, "name": "Den", "birth": "29.02.2000"})
    print(
        sorted([user["name"] for user in select("name > B")])
        == sorted(["Den", "Bob", "Chuck"])
    )
    print([user["name"] for user in select("id <= 2")] == ["Ann", "Den"])
    print(*select("birth >= 12.04.2001"), sep="\n")
    # {"id": 3, "name": "Bob", "birth": "05.03.2002"},
    # {"id": 4, "name": "Chuck", "birth": "07.06.2001"},
    """
