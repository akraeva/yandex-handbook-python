# Yandex / Хендбуки / Основы Python
# 4.1. Функции. Области видимости. Передача параметров в функции


def p_4_1_a():
    """
    Когда программа запускается, она может обращаться к пользователю
    по имени — это просто и приятно. Научимся писать функцию, которая
    выводит приветствие в нужном формате.
    Напишите функцию print_hello(name), которая принимает имя и
    выводит строку приветствия: Hello, <имя>!
    Не добавляйте вызовов функции вне её тела — программа будет
    использоваться как библиотека.

    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    Для форматирования строки используйте f-строку.
    """

    def print_hello(name):
        print(f"Hello, {name}!")


def p_4_1_b():
    """
    Программы часто используют математические функции — например,
    чтобы упростить дробь или найти общий множитель.
    Одной из таких базовых функций является НОД — наибольший общий
    делитель двух чисел.
    Напишите функцию gcd, которая принимает два натуральных числа
    и возвращает их наибольший общий делитель.

    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    def gcd(*args):
        a = min(args)
        b = max(args)
        while b:
            a, b = b, a % b
        return a


def p_4_1_с():
    """
    Иногда в программе нужно узнать, сколько цифр содержит число.
    Например, чтобы проверить длину пароля, номера телефона или
    банковского счёта. Разработайте функцию number_length, которая
    принимает одно целое число и возвращает его длину без учёта знака.
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    def number_length(num):
        count = sum(1 for n in str(num) if n.isdigit())
        return count


def p_4_1_d():
    """
    Программа может обрабатывать любые данные — даже содержимое
    кошелька. Представьте, что у вас есть список купюр и монет.
    Нужно выбрать из него только мелочь — всё, что меньше 100 рублей.
    Напишите функцию take_small(money), которая принимает список
    номиналов и возвращает новый список — только с теми значениями,
    которые меньше 100. Порядок элементов должен сохраниться.
    Примечание Исходный список должен остаться без изменений.
    В решении не должно быть вызовов требуемых функций.
    """

    def take_small(money):
        return [coin for coin in money if coin < 100]


def p_4_1_e():
    """
    Допустим, вы создаёте онлайн-кликер — игру, где каждое нажатие
    увеличивает счёт. Реализуем основу такой игры на Python.
    Создайте две функции:
    - click() — увеличивает значение счётчика на 1;
    - get_count() — возвращает текущее значение счётчика.
    Примечание В решении не должно быть вызовов функций.
    """
    __count = 0

    def click():
        global __count
        __count += 1

    def get_count():
        return __count


def p_4_1_f():
    """
    Пора потренироваться с изменяемыми переменными и логикой
    принятия решений.  Петя и Ваня решили сыграть в игру
    «Перетягивание числа». Правила простые:
    - Петя увеличивает общее число.
    - Ваня уменьшает его.
    - Если в итоге получается положительное число — побеждает Петя.
    - Если отрицательное — выигрывает Ваня.
    - Если сумма равна нулю — ничья.
    Создайте две функции:
    - move(player, number) — принимает имя игрока и его число,
    обновляет общий счёт;
    - game_over() — возвращает результат: 'Петя', 'Ваня' или 'Ничья'.
    Общая сумма изначально равна 0.
    Примечание В решении не должно быть вызовов требуемых функций.
    """


_score = 0


def move(player, number):
    global _score
    if player == "Петя":
        _score += number
    elif player == "Ваня":
        _score -= number


def game_over():
    if _score > 0:
        return "Петя"
    elif _score < 0:
        return "Ваня"
    else:
        return "Ничья"


def p_4_1_g():
    """
    Работа с таблицами чисел — важный навык, особенно если вы
    анализируете данные. Попробуем найти самое большое число
    в такой таблице. Напишите функцию max2D(matrix), которая
    принимает список списков целых чисел и возвращает максимальный элемент
    Примечание В решении не должно быть вызовов требуемых функций.
    """

    def max2D(matrix):
        result = max(max(num for num in row) for row in matrix)
        return result

    # test
    print(max2D([[1, 1, 1], [1, 2, 1], [1, 1, 1]]))
    print(max2D([[-5, -43, 72, 89], [-40, 92, -1, -73], [30, -75, 23, 94]]))


def p_4_1_h():
    """
    Допустим, у вас есть список чисел, и вы хотите разбить его на
    возрастающие фрагменты — участки, где каждое следующее число
    больше предыдущего. Такая задача может пригодиться при анализе
    последовательностей, графиков или пользовательских действий.
    Напишите функцию fragments(numbers), которая принимает список
    целых чисел и возвращает список вложенных списков — каждый из
    которых представляет собой возрастающий отрезок исходной
    последовательности.
    Примечание В решении не должно быть вызовов требуемых функций.
    """

    def fragments(numbers):
        result = []
        arr = []
        for num in numbers:
            if not arr or arr[-1] < num:
                arr.append(num)
            else:
                result.append(arr.copy())
                arr.clear()
                arr.append(num)
        result.append(arr.copy())
        return result

    # test
    print(
        fragments([0, 4, 5, -9, -6, 3, 2, 3, 4, 9])
        == [[0, 4, 5], [-9, -6, 3], [2, 3, 4, 9]]
    )
    print(
        fragments([-4, -2, 5, 0, 3, 7, -8, -2, 6, 7, 6, 8, 10, 5, 7, 8])
        == [[-4, -2, 5], [0, 3, 7], [-8, -2, 6, 7], [6, 8, 10], [5, 7, 8]]
    )


def p_4_1_i():
    """
    Программы часто работают с датами.
    Допустим, у вас есть номер месяца и язык интерфейса.
    Напишите функцию, которая по этим данным возвращает название
    месяца с заглавной буквы.
    Создайте функцию month(number, language), которая принимает:
    - number — номер месяца от 1 до 12,
    - language — строку "ru" или "en",
    - возвращает название соответствующего месяца на нужном языке
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    def month(number, language):
        transtare = {
            "ru": [
                "Январь",
                "Февраль",
                "Март",
                "Апрель",
                "Май",
                "Июнь",
                "Июль",
                "Август",
                "Сентябрь",
                "Октябрь",
                "Ноябрь",
                "Декабрь",
            ],
            "en": [
                "January",
                "February",
                "March",
                "April",
                "May",
                "June",
                "July",
                "August",
                "September",
                "October",
                "November",
                "December",
            ],
        }
        return transtare[language][number - 1]

    # test
    print(month(1, "en") == "January")
    print(month(7, "ru") == "Июль")


def p_4_1_j():
    """
    Давайте теперь научимся преобразовывать строку чисел в структуру
    данных, с которой удобно работать. Создайте функцию split_numbers(text),
    которая принимает строку целых чисел, разделённых пробелами,
    и возвращает кортеж этих чисел.

    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    Вы можете спросить: почему кортеж, а не список.
    Всё дело в безопасности. Кортежи неизменяемые коллекции и их
    безопаснее передавать в функцию или из неё.
    """

    def split_numbers(text):
        return tuple(map(int, text.split()))

    # test
    print(split_numbers("1 2 3 4 5") == (1, 2, 3, 4, 5))
    print(split_numbers("1 -2 3 -4 5") == (1, -2, 3, -4, 5))


def p_4_1_k():
    """
    Представьте, что вы смотрите на линию горизонта.
    Перед вами — последовательность чисел, обозначающих высоты.
    Иногда среди них встречаются «горы» — точки, которые выше своих
    ближайших соседей. Напишите функцию find_mountains(heights),
    которая принимает список высот и возвращает кортеж номеров
    всех гор. Нумерация начинается с 1.
    Считаем, что края списка окружены горами бесконечной высоты
    — поэтому сравниваются только внутренние точки.
    Примечание В решении не должно быть вызовов требуемых функций.
    """

    def find_mountains(data):
        result = tuple(
            i + 1
            for i in range(1, len(data) - 1)
            if data[i - 1] < data[i] > data[i + 1]
        )
        return result

    # test
    print(find_mountains([1, 2, 1, 4, 1]) == (2, 4))
    print(find_mountains([5, 1, 10, 2, 3, 4, 3, 20]) == (3, 6))


def p_4_1_l():
    """
    Теперь давайте посмотрим на местность с высоты — словно вы летите
    на самолёте. Перед вами — прямоугольная таблица с высотами.
    Внутри этой сетки тоже могут встречаться «горы» — точки,
    которые выше всех своих соседей по 8 направлениям.
    Создайте функцию find_mountains(data), которая принимает список
    списков чисел и возвращает кортеж пар номеров всех гор.
    Нумерация начинается с 1 (по строкам и столбцам).
    Края таблицы считаются окружёнными горами бесконечной высоты,
    поэтому в них гор быть не может.
    Примечание В решении не должно быть вызовов требуемых функций.
    """

    def chek(data, i, j):
        num = data[i][j]
        neighbours = [n for row in data[i - 1 : i + 2] for n in row[j - 1 : j + 2]]
        neighbours.remove(num)
        return num > max(neighbours)

    def find_mountains(data):
        result = []
        for i in range(1, len(data) - 1):
            for j in range(1, len(data[i]) - 1):
                if chek(data, i, j):
                    result.append((i + 1, j + 1))
        return tuple(result)

    # test
    print(find_mountains([[1, 1, 1], [1, 2, 1], [1, 1, 1]]) == ((2, 2),))
    print(
        find_mountains(
            [
                [1, 1, 1, 1, 1, 1],
                [1, 2, 1, 5, 4, 1],
                [1, 1, 1, 3, 4, 3],
                [2, 3, 3, 1, 2, 3],
                [1, 2, 1, 3, 2, 1],
            ]
        )
        == ((2, 2), (2, 4))
    )


def p_4_1_m():
    """
    Представьте, что вы создаёте «умную» систему вывода, которая не
    повторяет уже напечатанные строки. Это удобно, когда важно не
    асорять лог или консоль дубликатами.
    Создайте функцию modern_print(text), которая печатает переданную
    строку, только если она ещё не выводилась ранее.
    Все уникальные строки должны запоминаться.
    Примечание В решении не должно быть вызовов требуемых функций.
    """

    _history = []

    def modern_print(text):
        global _history
        if text not in _history:
            print(text)
            _history.append(text)

    # modern_print("Hello!")
    # modern_print("Hello!")
    # modern_print("How do you do?")
    # modern_print("Hello!")


def p_4_1_n():
    """
    В шахматах конь двигается особым образом: буквой "Г".
    Он может съесть фигуру, если та находится на расстоянии
    двух клеток по одной оси и одной — по другой.
    Напишите функцию can_eat(horse, other), которая принимает:
    — координаты коня,
    — координаты другой фигуры (оба значения — кортежи из двух чисел),
    — возвращает True, если конь может атаковать фигуру,
    и False — если не может.

    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    def can_eat(horse, other):
        answer = sorted([abs(other[0] - horse[0]), abs(other[1] - horse[1])]) == [1, 2]
        return answer

    # print(can_eat((2, 1), (4, 2)) == True, can_eat((5, 5), (6, 6)) == False)


def p_4_1_o():
    """
    Теперь научимся превращать строки с данными в словари.
    Это полезно, если вы получаете настройки из текстового
    файла или обрабатываете ввод от пользователя.
    Создайте функцию get_dict(text), которая принимает строку вида:
    ключ1=значение1;ключ2=значение2;...
    и возвращает словарь с этими парами.
    Тип ключей — всегда строка. Значения попробуйте привести
    к int или float, если это возможно.
    Примечание В решении не должно быть вызовов требуемых функций.
    """

    def value_type(value):
        try:
            return int(value)
        except ValueError:
            try:
                return float(value)
            except ValueError:
                return value

    def get_dict(text):
        data = {
            key: value_type(value)
            for row in text.split(";")
            for key, value in [row.split("=")]
        }
        return data

    # test
    print(
        get_dict("a=A;b=2;c=-3.5") == {"a": "A", "b": 2, "c": -3.5},
        get_dict("id=3-76;ip=127.0.0.1;phone=+7-(123)-456-78-90")
        == {"id": "3-76", "ip": "127.0.0.1", "phone": "+7-(123)-456-78-90"},
    )


def p_4_1_p():
    """
    Создайте функцию is_palindrome(x), которая принимает одно
    значение (число, строку, кортеж или список) и возвращает True,
    если передан палиндром, и False — в противном случае.
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    def is_palindrome(x):
        if type(x) in (int, float):
            return str(x) == str(x)[::-1]
        if type(x) in (list, tuple):
            return x == x[::-1]
        if type(x) is str:
            return x == x[::-1]
            # "".join(x.lower().strip().split()) <= обработка строк не требуется

    # print(is_palindrome(123) == False, is_palindrome([1, 2, 1, 2, 1]) == True)


def p_4_1_q():
    """
    Простые числа — важное понятие в математике и программировании.
    Они делятся только на 1 и на себя. Проверка числа на простоту
    используется в шифровании, аналитике и олимпиадных задачах.
    Напишите функцию is_prime, которая принимает натуральное число,
    а возвращает булево значение: True — если переданное число
    простое, а иначе — False.
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    def is_prime(num):
        if num < 4:
            return True
        for div in range(2, int(num**0.5) + 1):
            if num % div == 0:
                return False
        return True

    # print(is_prime(1001459) == True, is_prime(79701) == False)


def p_4_1_r():
    """
    Теперь научимся объединять отсортированные коллекции в одну.
    Это важный шаг в алгоритмах сортировки и при обработке данных.
    Напишите функцию merge, которая принимает два отсортированных
    по возрастанию кортежа целых чисел, а возвращает один из
    всех переданных чисел.
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """
    # tuple(sorted(arr1 + arr2)) <= "Воздержитесь от использования стандартных сортировок"

    def merge(arr1, arr2):
        result = []
        i, j = 0, 0
        while i < len(arr1) and j < len(arr2):
            if arr1[i] <= arr2[j]:
                result.append(arr1[i])
                i += 1
            else:
                result.append(arr2[j])
                j += 1
        result.extend(arr1[i:])
        result.extend(arr2[j:])
        return tuple(result)

    # test
    print(
        merge((1, 2), (3, 4, 5)) == (1, 2, 3, 4, 5),
        merge((7, 12), (1, 9, 50)) == (1, 7, 9, 12, 50),
    )


def p_4_1_s():
    """
    Иногда нужно поменять содержимое двух списков местами
    так, чтобы ссылки на них остались прежними.
    То есть объекты остаются теми же, а данные — полностью меняются.
    Создайте функцию swap(a, b), которая принимает два списка
    и меняет их содержимое местами. Результат должен быть виден
    во всех переменных, которые ссылаются на эти списки.
    Примечание В решении не должно быть вызовов требуемых функций.
    """

    # для меня было сложно не путать переименовывание и перезаполнение
    def swap(a, b):
        a[:], b[:] = b[:], a[:]

    # test
    a = b = [1, 2]
    c = d = [2, 1]
    swap(a, c)
    print((a, b, c, d) == ([2, 1], [2, 1], [1, 2], [1, 2]))


def p_4_1_t():
    """
    В Древнем Риме использовалась особая система счисления. Чтобы
    попрактиковаться в сложении римских чисел, напишите функцию roman,
    которая принимает два натуральных числа a и b, а возвращает строку вида:
    РИМСКОЕ_А + РИМСКОЕ_B = РИМСКАЯ_СУММА
    Примечание В решении не должно быть вызовов требуемых функций.
    """

    def translate(x):
        d = [["I", "V", "X"], ["X", "L", "C"], ["C", "D", "M"], ["M", "", ""]]
        result = ""
        num = [int(n) for n in str(x)]
        for i, n in enumerate(num[::-1]):
            if n != 0:
                ch1, ch2, ch3 = d[i]
                if n == 9:
                    result = ch1 + ch3 + result
                elif n > 4:
                    result = ch2 + ch1 * (n - 5) + result
                elif n == 4:
                    result = ch1 + ch2 + result
                else:
                    result = ch1 * n + result
        return result

    def roman(a, b):
        return f"{translate(a)} + {translate(b)} = {translate(a+b)}"

    # print(roman(10, 9) == "X + IX = XIX")
