# Yandex / Хендбуки / Основы Python
# 3.2. Множества, словари


def p_3_2_a():
    """
    Впереди — задачи, посвящённые множествам и словарям — ключевым структурам
    данных в Python. Вы научитесь быстро находить уникальные значения, считать
    частоты, искать пересечения и многое другое. Во многих промышленных задачах
    требуется понять, из каких символов состоят данные, и избавиться
    от повторений. Напишите программу, которая по введённой строке выводит все
    её уникальные символы — без повторений.

    Формат ввода Вводится одна строка.

    Формат вывода Требуется вывести все символы этой строки без повторений.
    Порядок вывода не имеет значения.
    """
    print("".join(set(input())))


def p_3_2_b():
    """
    Теперь нас интересует пересечение данных: какие символы одинаковы
    в двух разных строках? Такую задачу можно встретить в анализе логов,
    данных с датчиков или при обработке пользовательского ввода.
    Напишите программу, которая находит общие символы в двух введённых строках.
    Символы не должны повторяться в выводе.

    Формат ввода Вводится две строки.

    Формат вывода Требуется вывести все общие символы этих строк без
    повторений. Порядок вывода не имеет значения.
    """
    print(*set(input()) & set(input()), sep="")


def p_3_2_с():
    """
    Счёт продолжается!
    Мы снова наблюдаем за движением поезда — и продолжаем собирать все
    объекты, которые попадаются в поле зрения. Теперь ваша задача — собрать
    единый список всех увиденных объектов, независимо от того, в каких
    именно строках они встречались.

    Формат ввода В первой строке записано натуральное число
    N — количество выделенных придорожных местностей.
    В каждой из N последующих строк записано описание придорожной местности.

    Формат вывода Вывести все найденные объекты в придорожных местностях.
    """
    res = set()
    for _ in range(int(input())):
        res = res.union(input().split())
    print(*res, sep="\n")


def p_3_2_d():
    """
    В детском саду завели "кашевую статистику". Каждый ребёнок любит манную,
    овсяную или обе каши. Воспитателю важно быстро узнать, сколько детей
    обожают и ту, и другую кашу. Напишите программу, которая определит,
    сколько учеников любят обе каши.

    Формат ввода В первых двух строках указывается количество детей,
    любящих манную и овсяную каши (N и M). Затем идут N строк — фамилии детей,
    которые любят манную кашу, и M строк с фамилиями детей, любящих
    овсяную кашу. Гарантируется, что в группе нет однофамильцев.

    Формат вывода Количество учеников, которые любят обе каши.
    Если таких не окажется, в строке вывода нужно написать «Таких нет».
    """
    n, m = int(input()), int(input())
    ch = set(input() for _ in range(n)) & set(input() for _ in range(m))
    print(len(ch) if ch else "Таких нет")


def p_3_2_e():
    """
    После статистики по «любителям обеих каш» воспитателю захотелось
    знать другое: сколько детей любят только одну кашу — либо манную,
    либо овсяную, но не обе сразу. Это поможет спланировать меню так,
    чтобы угодить каждому!

    Формат ввода В первых двух строках указывается количество детей,
    любящих манную и овсяную каши (N и M). Затем идут N+M строк —
    перемешанные фамилии детей. Гарантируется, что в группе нет однофамильцев.

    Формат вывода Количество учеников, которые любят только одну кашу.
    Если таких не окажется, в строке вывода нужно написать «Таких нет».
    """
    n, m = int(input()), int(input())
    ch = set(input() for _ in range(n + m))
    print(len(ch) - (m + n - len(ch)) if m + n != 2 * len(ch) else "Таких нет")


def p_3_2_f():
    """
    Мы уже посчитали, сколько детей любят только одну кашу.
    Теперь давайте выясним, кто именно это делает — и выведем их по алфавиту.
    Это поможет воспитателю персонально поблагодарить каждого за преданность
    любимому блюду. Напишите программу, которая позволит воспитателю узнать,
    какие дети любят только одну кашу.

    Формат ввода В первых двух строках указывается количество детей,
    любящих манную и овсяную каши (N и M).
    Затем идут N+M строк — перемешанные фамилии детей.
    Гарантируется, что в группе нет однофамильцев.

    Формат вывода В алфавитном порядке фамилии учеников, которые любят
    только одну кашу. Если таких не окажется, в строке вывода нужно
    написать «Таких нет».
    """
    intersection = set()
    children = set()
    n, m = int(input()), int(input())
    for _ in range(n + m):
        child = input()
        if child in children:
            intersection.add(child)
        else:
            children.add(child)
    print(
        "\n".join(sorted(children - intersection))
        if children - intersection
        else "Таких нет"
    )


def p_3_2_g():
    """
    Напишите программу, которая по введённому английскому тексту кодирует
    каждое слово в азбуке Морзе. Каждая буква заменяется на последовательность
    точек и тире. В качестве тире используйте обычный дефис: -, а в качестве
    точки — точку .. Например, буква g превратится в трёхсимвольную строку
    --.. Между закодированными буквами ставится ровно один пробел. Например,
    слово Help превратится в .... . .-.. .--..
    Обратите внимание, что строчные и заглавные буквы кодируются одинаково.

    Формат ввода Весь текст записан в единственной строке. Текст состоит из
    английских букв и пробелов, других символов в тексте нет.
    В тексте не может быть двух или более пробелов подряд.

    Формат вывода
    Выведите каждое слово исходного текста, закодированное азбукой Морзе,
    на отдельной строке. Количество строк в ответе должно совпадать с
    количеством слов в исходном тексте.
    """
    morse_dict = {
        "A": ".-",
        "B": "-...",
        "C": "-.-.",
        "D": "-..",
        "E": ".",
        "F": "..-.",
        "G": "--.",
        "H": "....",
        "I": "..",
        "J": ".---",
        "K": "-.-",
        "L": ".-..",
        "M": "--",
        "N": "-.",
        "O": "---",
        "P": ".--.",
        "Q": "--.-",
        "R": ".-.",
        "S": "...",
        "T": "-",
        "U": "..-",
        "V": "...-",
        "W": ".--",
        "X": "-..-",
        "Y": "-.--",
        "Z": "--..",
        "0": "-----",
        "1": ".----",
        "2": "..---",
        "3": "...--",
        "4": "....-",
        "5": ".....",
        "6": "-....",
        "7": "--...",
        "8": "---..",
        "9": "----.",
    }
    print(
        *(
            " ".join(morse_dict[ch] for ch in word if ch in morse_dict)
            for word in input().upper().split()
        ),
        sep="\n",
    )


def p_3_2_h():
    """
    Каждый воспитанник детского сада может любить одну или несколько каш.
    Воспитателю нужно быстро получить список фамилий тех, кто любит
    определённый вид каши. Напишите программу, которая по списку учеников
    и их любимых каш определяет, кто именно любит заданную кашу.

    Формат ввода В первой строке задаётся количество детей в группе (N).
    В следующих N строках записана фамилия ребенка и список его любимых каш.
    В последней строке записана каша, информацию о которой хочет
    получить воспитатель.

    Формат вывода Фамилии учеников, которые любят заданную кашу,
    в алфавитном порядке. Если таких не окажется, в строке вывода
    нужно написать «Таких нет».
    """
    porridge_fans = {}
    for _ in range(int(input())):
        name, *preferences = input().split()
        for p in preferences:
            porridge_fans[p] = porridge_fans.get(p, []) + [name]
    request = input()
    print(
        "\n".join(sorted(porridge_fans[request]))
        if request in porridge_fans
        else "Таких нет"
    )


def p_3_2_i():
    """
    Поможем детям подсчитать, сколько животных и деревьев каждого вида
    встречается за окном поезда. Напишите программу, которая по текстовому
    описанию местности подсчитывает, сколько раз каждое слово встречается
    во входных данных.

    Формат ввода В каждой строке записано описание придорожной местности.
    Конец ввода обозначается пустой строкой.

    Формат вывода Список увиденного и их количество.
    Порядок вывода не имеет значения.
    """
    word_counts = {}
    while words := input():
        for word in words.split():
            word_counts[word] = word_counts.get(word, 0) + 1
    print(*(f"{word} {count}" for word, count in word_counts.items()), sep="\n")


def p_3_2_j():
    """
    Для международных документов русский текст преобразуется с использованием
    латинского алфавита. ГОСТ Р 52535.1-2006 задаёт правила транслитерации
    идентификационных карт. Ниже приведена таблица замен:

    А — A
    Б — B
    В — V
    Г — G
    Д — D
    Е — E
    Ё — E
    Ж — ZH
    З — Z
    И — I
    Й — I
    К — K
    Л — L
    М — M
    Н — N
    О — O
    П — P
    Р — R
    С — S
    Т — T
    У — U
    Ф — F
    Х — KH
    Ц — TC
    Ч — CH
    Ш — SH
    Щ — SHCH
    Ы — Y
    Э — E
    Ю — IU
    Я — IA
    Давайте транслитерируем русский текст.
    Букву «ё» транслитерируйте как «e», «й» как «и», а «ъ» и «ь»
    (и их заглавные версии «Ъ» и «Ь») должны исчезнуть из текста.
    Строчные буквы заменяются на строчные, заглавные заменяются на заглавные.
    Если заглавная буква превращается при транслитерации в несколько букв,
    то заглавной должна остаться только первая из них (например, «Ц» → «Tc»).
    Все некириллические символы должны остаться на месте.

    Формат ввода В единственной строке задан русский текст. Текст может
    состоять из любых символов. Вам необходимо транслитерировать только
    русские буквы, а остальные оставить на месте. Гарантируется, что нет
    слов, состоящих только из букв «ъ» и «ь».

    Формат вывода Выведите одну строку — транслитерированный текст.
    """
    translit_dict = {
        "А": "A",
        "Б": "B",
        "В": "V",
        "Г": "G",
        "Д": "D",
        "Е": "E",
        "Ё": "E",
        "Ж": "ZH",
        "З": "Z",
        "И": "I",
        "Й": "I",
        "К": "K",
        "Л": "L",
        "М": "M",
        "Н": "N",
        "О": "O",
        "П": "P",
        "Р": "R",
        "С": "S",
        "Т": "T",
        "У": "U",
        "Ф": "F",
        "Х": "KH",
        "Ц": "TC",
        "Ч": "CH",
        "Ш": "SH",
        "Щ": "SHCH",
        "Ы": "Y",
        "Э": "E",
        "Ю": "IU",
        "Я": "IA",
    }
    translit_text = ""
    text = input()
    for ch in text:
        upper_ch = ch.upper()
        if upper_ch in translit_dict:
            translit = translit_dict[upper_ch]
            translit_text += translit.capitalize() if ch.isupper() else translit.lower()
        else:
            translit_text += ch if upper_ch not in "ЬЪ" else ""
    print(translit_text)


def p_3_2_k():
    """
    Начальник кадровой службы хочет выяснить, сколько мужчин-однофамильцев
    работает в организации. У него есть список фамилий, и на его основании
    требуется определить количество сотрудников, чьи фамилии совпадают хотя
    бы с одной другой. Напишите программу, которая по списку фамилий
    сотрудников подсчитывает общее число однофамильцев — то есть людей,
    чья фамилия в списке встречается более одного раза.

    Формат ввода В первой строке указывается количество мужчин — сотрудников
    организации (N). Затем идут N строк с фамилиями этих сотрудников в
    произвольном порядке.

    Формат вывода Количество однофамильцев в организации.
    """
    names = {}
    for _ in range(int(input())):
        name = input()
        names[name] = names.get(name, 0) + 1
    print(sum(count for count in names.values() if count > 1))


def p_3_2_l():
    """
    Вновь поможем сотруднику отдела кадров выяснить, сколько
    мужчин-однофамильцев работает в организации — теперь с более подробным
    отчётом. Напишите программу, которая по списку фамилий сотрудников
    выводит список всех однофамильцев (тех, чьи фамилии встречаются более
    одного раза), а также количество их повторений.

    Формат ввода В первой строке указывается количество мужчин — сотрудников
    организации (N). Затем идут N строк с фамилиями этих сотрудников в
    произвольном порядке.

    Формат вывода Список однофамильцев в организации с указанием их количества
    в алфавитном порядке. Если таковых нет — вывести «Однофамильцев нет».
    """
    names = {}
    for _ in range(int(input())):
        name = input()
        names[name] = names.get(name, 0) + 1
    namesakes = sorted(
        f"{name} - {count}" for name, count in names.items() if count > 1
    )
    print("\n".join(namesakes) if namesakes else "Однофамильцев нет")


def p_3_2_m():
    """
    Главный повар детского сада готовит меню на праздник и хочет выбрать
    блюда, которые ни разу не подавались на этой неделе. В его распоряжении
    есть список блюд:
    - которые можно приготовить в столовой сегодня;
    - которые были приготовлены в каждый из дней недели.
    Напишите программу, которая по списку доступных сегодня блюд и истории
    приготовления на неделе определяет, что из этого можно приготовить нового.

    Формат ввода Число блюд (N), которые можно приготовить в столовой.
    N строк с названиями блюд. Число дней (M), о которых имеется информация.
    M блоков строк для каждого из списков. В первой строке каждого блока
    записано число блюд в заданный день, затем перечисляются эти блюда.

    Формат вывода Список блюд, которые ещё не готовились на этой неделе
    в алфавитном порядке. Если все возможные блюда уже были приготовлены,
    следует вывести «Готовить нечего».
    """
    available_dishes = set(input() for _ in range(int(input())))
    weekly_dishes = set(
        input() for _ in range(int(input())) for __ in range(int(input()))
    )
    menu = sorted(available_dishes - weekly_dishes)
    print("\n".join(menu) if menu else "Готовить нечего")


def p_3_2_n():
    """
    Главный повар детского сада хочет быстрее определять, какие блюда можно
    приготовить на обед. У него есть список доступных продуктов и список
    рецептов. Напишите программу, которая по списку имеющихся продуктов и
    рецептам определяет, какие блюда можно приготовить.

    Формат ввода Число продуктов (N), которые имеются в наличии. N строк с
    названиями продуктов. Число рецептов (M), о которых имеется информация.
    M блоков строк для каждого из рецептов. В первой строке каждого блока
    записано название блюда. Во второй — число ингредиентов.
    Затем перечисляются сами ингредиенты, требуемые для приготовления блюда.

    Формат вывода Список блюд, которые можно приготовить в алфавитном порядке.
    Если ни одно из блюд нельзя приготовить, следует вывести «Готовить нечего».
    """
    recipes = {}
    ingredients = set(input() for _ in range(int(input())))
    for _ in range(int(input())):
        dish = input()
        recipes[dish] = set(input() for __ in range(int(input())))
    menu = sorted(name for name, recipe in recipes.items() if ingredients >= recipe)
    print("\n".join(menu) if menu else "Готовить нечего")


def p_3_2_o():
    """
    У программистов особые отношения с двоичной системой счисления —
    ведь именно в ней работает вся цифровая техника. Продолжим тренировки
    в статистической обработке данных и научимся анализировать числа с позиции
    их представления в двоичной системе. Напишите программу, которая по списку
    целых чисел определяет:
    - количество разрядов;
    - количество единиц;
    - количество нулей.

    Формат ввода Вводится последовательность чисел, записанных через пробел.

    Формат вывода Вывести список словарей с требуемой статистикой.

    Примечание
    Вывод в примерах отформатирован только для визуальной наглядности.
    Все пробельные символы при проверке игнорируются.
    Порядок словарей обязан совпадать с порядком переданных чисел.
    Порядок ключей в словаре не имеет значения.
    """


nums_dict = []
for num in input().split():
    bin_num = bin(int(num))[2:]
    nums_dict.append(
        {
            "digits": len(bin_num),
            "units": bin_num.count("1"),
            "zeros": bin_num.count("0"),
        }
    )
print(nums_dict)


def p_3_2_p():
    """
    Дети в поезде снова играют в любимую игру — считать зверей за окном.
    На этот раз их заинтересовало, что находится рядом с зайками.
    Поможем им разобраться! Напишите программу, которая по описанию
    придорожной местности находит все объекты, стоящие рядом с зайками —
    слева или справа от слова зайка.

    Формат ввода В каждой записано описание придорожной местности.
    Конец ввода обозначается пустой строкой.

    Формат вывода Определите список увиденного рядом с зайками без повторений.
    Порядок вывода не имеет значения.

    Примечание Считается, что объект находится рядом,
    если он записан справа или слева от требуемого.
    """
    result = set()
    while area := input():
        description = area.split()
        while "зайка" in description:
            i = description.index("зайка")
            if i + 1 < len(description):
                result.add(description[i + 1])
            if i - 1 > -1:
                result.add(description[i - 1])
            description.pop(i)
    print(*sorted(result), sep="\n")


def p_3_2_q():
    """
    Теория шести рукопожатий гласит, что любые два человека на планете
    могут быть связаны друг с другом через максимум шесть знакомых.
    Но мы не будем идти так далеко — давайте ограничимся двумя уровнями
    знакомства. Напишите программу, которая по списку пар друзей для каждого
    человека определяет список его друзей второго уровня — то есть друзей
    его друзей, исключая его самого и его непосредственных друзей.

    Формат ввода В каждой строке записывается два имени.
    Окончанием ввода служит пустая строка.

    Формат вывода Выведите список всех людей и их «друзей 2-го уровня»
    в формате «Человек: Друг1, Друг2, ...». Список людей и друзей в каждой
    строке требуется вывести в алфавитном порядке без повторений.
    """
    f_dict = {}
    while friends := input():
        f1, f2 = friends.split()
        f_dict[f1] = f_dict.get(f1, []) + [f2]
        f_dict[f2] = f_dict.get(f2, []) + [f1]

    for name, friends in sorted(f_dict.items()):
        sub_friends = sorted(
            set(
                sub_friend
                for friend in friends
                for sub_friend in f_dict[friend]
                if sub_friend != name and sub_friend not in friends
            )
        )
        print(f"{name}: {', '.join(sub_friends)}")


def p_3_2_r():
    """
    На пиратской карте отмечено множество точек, в которых, по слухам, зарыты
    сокровища. Каждая точка задана координатами в километрах.
    Капитан Крюк хочет собрать как можно больше кладов за один маршрут.
    Однако есть ограничение: между двумя соседними точками маршрута можно
    перемещаться только в том случае, если координаты этих точек различаются
    только последней цифрой — как по оси x, так и по оси y.

    Например:
    Из точки (15, 10) можно попасть в (18, 16) — координаты отличаются только
    последней цифрой (5 → 8 и 0 → 6). Но из (14, 68) в (19, 71) попасть нельзя,
    потому что десятки и сотни отличаются. Также нельзя попасть из (5, 12)
    в (13, 14), так как 5 и 13 различаются не только в последнем разряде.
    Напишите программу, которая по списку координат точек определяет,
    какое максимальное количество точек может входить в маршрут Капитана Крюка,
    построенный по описанному правилу.

    Формат ввода В первой строке указано число количество точек, отмеченных
    на карте сокровищ. В следующих N строках содержатся пары координат.
    Координаты — целые числа не меньше нуля и не больше 10^9.
    Гарантируется, что совпадающих точек в списке нет.

    Формат вывода Выведите одно число — максимальное количество точек,
    которое Капитан Крюк сможет посетить по маршруту, построенному
    по описанным правилам.
    """
    t_map = {}
    for _ in range(int(input())):
        x, y = input().split()
        point = int(x) // 10 * 10 ** (len(y)) + int(y) // 10
        t_map[point] = t_map.get(point, 0) + 1
    print(max(t_map.values()))


def p_3_2_s():
    """
    Ребята приносят игрушки в детский сад и играют все вместе.
    Сегодня они решили выяснить, игрушки какого типа принадлежат только одному
    из детей.  Напишите программу, которая по списку детей и их игрушек
    определяет список игрушек, которые есть только у одного ребёнка.
    Выведите их в алфавитном порядке.

    Формат ввода
    В первой строке задается количество детей в группе (N).
    В каждой из следующих N строк записано имя ребенка и его игрушки в формате:
    Имя: игрушка1, игрушка2, ....

    Формат вывода Список игрушек, которые есть только у одного из
    детей в алфавитном порядке.
    """
    toy_dict = {}
    for _ in range(int(input())):
        for toy in set(input().split(": ")[-1].split(", ")):
            toy_dict[toy] = toy_dict.get(toy, 0) + 1
    print(*sorted(toy for toy in toy_dict if toy_dict[toy] == 1), sep="\n")


def p_3_2_t():
    """
    Напомним, что взаимно простыми называются числа, которые не имеют
    общих делителей, кроме 1. Напишите программу, которая:

    - получает список чисел, разделённых точкой с запятой и пробелом;
    - для каждого числа определяет, с какими другими числами оно взаимно просто;
    - выводит результат в порядке возрастания чисел без повторений;
    - если для числа не найдено ни одного взаимно простого числа — его не нужно
    выводить вовсе.

    Формат ввода Задана последовательность чисел записанных
    через точку с запятой (;) и пробел.

    Формат вывода Список чисел с указанием взаимно простых ему среди
    переданных. Все числа должны быть выведены в порядке возрастания
    без повторений. Строки следует отформатировать по правилу:
    число - взаимно простое 1, взаимно простое 2, ...
    Если для числа не было найдено ни одного взаимно простого,
    то и выводить его не требуется.
    """

    def are_coprime(a, b):
        while b:
            a, b = b, a % b
        return a == 1

    nums = set(int(x) for x in input().split("; "))
    result = {num: sorted(n for n in nums if are_coprime(num, n)) for num in nums}
    for num, values in sorted(result.items()):
        if values:
            print(f"{num} - {', '.join(map(str, values))}")
