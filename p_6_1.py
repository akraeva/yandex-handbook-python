# Yandex / Хендбуки / Основы Python
# 6.1. Модули math и numpy

from sys import stdin
import numpy as np
import math


def p_6_1_a(x):
    """
    Давайте вспомним начало нашего задачника, когда всё было просто:
    мы не использовали ни циклы, ни коллекции, ниобъектно-ориентированное
    программирование. Перед нами были только входные данные и
    требовалось предоставить результат.
    Напишите программу, которая вычисляет значение функции:

    Формат ввода Вводится действительное число x
    Формат вывода Одно число — значение функции в заданной точке.
    """
    # import math as m
    x = float(input())
    f = (
        math.log(pow(x, 3 / 16), 32)
        + pow(x, math.cos(math.pi * x / (2 * math.e)))
        - pow(math.sin(x / math.pi), 2)
    )
    print(f)

    """
    p_6_1_a(2.71)  # 0.4818035253577275
    p_6_1_a(12.345)  # 4.880549344757598
    """


def p_6_1_b():
    """
    Напишите программу, находящую наибольшие общие делители для всех
    переданных в стандартный поток последовательностей чисел.

    Формат ввода Вводятся строки чисел, разделённых пробелами.
    Формат вывода Последовательность чисел — наибольшие общие
    делители всех последовательностей.
    """
    # from sys import stdin
    # import math as m

    res = (math.gcd(*map(int, line.strip().split())) for line in stdin)
    print(*res, sep="\n")


def p_6_1_с():
    """
    Вася пришёл на образовательный семинар и обнаружил, что
    зрителей на мероприятии — N, а количество мест — M.
    Помогите Васе определить вероятность того, что он попадёт на семинар.

    Формат ввода Два числа N и M.
    Формат вывода Два числа — количество вариантов, в которых Вася
    попадает на семинар и количество всех вариантов групп на семинаре.
    """
    import math

    n, m = map(int, input().split())
    print(math.comb(n - 1, m - 1), math.comb(n, m))


def p_6_1_d():
    """
    Средним геометрическим нескольких положительных вещественных
    чисел называют такое число, которым можно заменить каждое из
    этих чисел так, чтобы их произведение не изменилось.

    Формат ввода Вводится последовательность рациональных чисел,
    разделённых пробелами.
    Формат вывода Одно число — среднее геометрическое переданных чисел.
    """
    # import math

    nums = [float(x) for x in input().split()]
    res = math.pow(math.prod(nums), 1 / len(nums))
    print(res)


def p_6_1_e():
    """
    Два выдуманных человечка Дека и Поля, пользуются каждый своей
    системой координат. Деке нравится представлять себя в декартовом
    пространстве, а Поле — в полярном.
    Напишите программу, определяющую кротчайшее расстояние,
    которое нужно пройти Деке и Поле, чтобы встретиться.

    Формат ввода В первой строке записаны координаты Деки:
    два рациональных числа — x и y
    Во второй строке записаны координаты Поли:
    два рациональных числа —  p и ϕ

    Формат вывода Одно число — расстояние между Декой и Полей.

    Примечание Дека и Поля живут на одной плоскости с общим центром.
    ϕ — измеряется в радианах.
    """
    # import math

    x_d, y_d = map(float, input().split())
    p, f = map(float, input().split())
    x_p = p * math.cos(f)
    y_p = p * math.sin(f)
    res = math.hypot(x_p - x_d, y_p - y_d)
    print(res)


def p_6_1_f():
    """
    Напишите функцию multiplication_matrix, которая принимает
    размер матрицы (N) и возвращает массив описывающий таблицу
    умножения N на N.
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    # import numpy as np
    def multiplication_matrix(n: int):
        row = np.arange(1, n + 1)
        res = np.outer(row, row)
        return res


def p_6_1_g():
    """
    Представьте, что вы пишете компьютерную игру «Шахматы».
    Вам надо смоделировать шахматную доску, которая представляет
    собой матрицу. Чёрная клетка представляется нулём,
    а белая — единицей. Если смотреть на доску сверху, то
    левая верхняя клетка — белая.
    Напишите функцию make_board, которая принимает размер
    шахматной доски, и возвращает матрицу, моделирующую
    заданную доску. Установите тип элементов матрицы int8.
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    # import numpy as np
    def make_board(n):
        board = np.zeros((n, n), dtype=np.int8)
        board[::2, ::2] = 1
        board[1::2, 1::2] = 1
        return board


def p_6_1_h():
    """
    Когда-то вы помогали детсадовцам с различными змейками.
    Давайте реализуем её на основе массивов.
    Напишите функцию snake, которая принимает
    ширину (M) и высоту (N) змейки, а также именованный
    параметр direction.
    Параметр direction могут принимать значения:
    H — горизонтальная змейка, используется по умолчанию;
    V — вертикальная змейка.
    Функция должна вернуть матрицу, представляющую змейку,
    с ячейками типа int16.
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    # import numpy as np
    def snake(m, n, direction="H"):
        res = np.zeros((n, m), dtype=np.int16)
        num = 1
        if direction == "H":
            for i in range(n):
                if i % 2 == 0:
                    res[i, :] = np.arange(num, num + m)
                else:
                    res[i, :] = np.arange(num + m - 1, num - 1, -1)
                num += m
        elif direction == "V":
            for i in range(m):
                if i % 2 == 0:
                    res[:, i] = np.arange(num, num + n)
                else:
                    res[:, i] = np.arange(num + n - 1, num - 1, -1)
                num += n
        return res


def p_6_1_i():
    """
    Напишите функцию rotate, принимающую двумерную матрицу и
    один из углов поворота: 90°, 180°, 270° и 360°.
    Функция должна вернуть новую матрицу соответствующую
    заданному повороту по часовой стрелке.
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    # import numpy as np
    def rotate(matrix, angle):
        return np.rot90(matrix, -angle // 90)


def p_6_1_j():
    """
    Напишите функцию stairs, принимающую вектор и возвращающую
    матрицу, в которой каждая строка является копией
    вектора со смещением.

    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    # import numpy as np
    def stairs(v):
        n = len(v)
        res = np.zeros((n, n), dtype=v.dtype)
        for i in range(n):
            res[i] = np.roll(v, i)
        return res
