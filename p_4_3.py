# Yandex / Хендбуки / Основы Python
# 4.3. Рекурсия. Декораторы. Генераторы


def p_4_3_a():
    """
    Большинство задач этой главы ориентировано на отработку
    навыков по разработке рекурсивных функций.
    Ваше решение будет использоваться как библиотека.
    Напишите функцию recursive_sum, которая находит сумму
    всех позиционных аргументов.
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций,
    за исключением рекурсивных. Трассировка вызова рекурсивной
    функции в обработке ответа не учитывается и показана для примера.
    """

    def recursive_sum(*args):
        if not args:
            return 0
        return args[0] + recursive_sum(*args[1:])

    # print(recursive_sum(1, 2, 3) == 6)


def p_4_3_b():
    """
    Рекурсия – отличный способ избавиться от циклов, особенно от while.
    Давайте вспомним одну из наших старых задач и модернизируем её.
    Напишите функцию recursive_digit_sum, которая находит сумму
    всех цифр натурального числа.
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций,
    за исключением рекурсивных. рассировка вызова рекурсивной
    функции в обработке ответа не учитывается и показана для примера.
    """

    def recursive_digit_sum(num):
        if not num:
            return 0
        return num % 10 + recursive_digit_sum(num // 10)

    # print(recursive_digit_sum(123) == 6)


def p_4_3_с():
    """
    Напишите функцию make_equation, которая по заданным коэффициентам
    строит строку, описывающую валидное с точки зрения Python
    выражение без использования оператора возведения в степень.
    Многочлен второй степени с коэффициентами  a, b и c, например,
    можно записать в виде: ((a)*x+b)*x+c
    Примечание Ваше решение должно содержать только функции.
    """

    def make_equation(*args):
        if len(args) == 1:
            return str(args[0])
        return f"({make_equation(*args[:-1])}) * x + {args[-1]}"

    # print(make_equation(3, 2, 1) == "((3) * x + 2) * x + 1")
    # print(make_equation(3, 1, 5, 3) == "(((3) * x + 1) * x + 5) * x + 3")


def p_4_3_d():
    """
    Напишите декоратор answer, который преобразует функцию,
    принимающую неограниченное число позиционных и именованных
    параметров и возвращает её результат с припиской
    "Результат функции: <значение>".
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    def answer(func):
        def new_funk(*args, **kwargs):
            result = func(*args, **kwargs)
            return f"Результат функции: {result}"

        return new_funk


def p_4_3_e():
    """
    В некоторых случаях полезно накапливать результат,
    а затем получать его единым списком.
    Реализуйте декоратор result_accumulator, который
    модернизирует функцию с неопределенным количеством
    позиционных параметров следующим образом:
    — Добавляет именованный параметр method со
      значениемпо умолчанию accumulate;
    — При вызове функции с параметром method равным
      accumulate, результат сохраняется в очередь(для каждой
      функции в собственную), а функция ничего не возвращает;
    — При вызове функции с параметром method равным drop,
      возвращается все накопленные результаты, а очередь сбрасывается.
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    def result_accumulator(func):
        result = []

        def new_funk(*args, method="accumulate", **kwargs):
            if method == "accumulate":
                result.append(func(*args, **kwargs))
            elif method == "drop":
                result.append(func(*args, **kwargs))
                data = result.copy()
                result.clear()
                return data

        return new_funk


def p_4_3_f():
    """
    Мы уже реализовывали функцию merge, которая способна
    "слить" два отсортированных списка в один. Чаще всего её
    применяют в рекурсивном алгоритме сортировки слиянием.
    Напишите рекурсивную функцию merge_sort, которая производит
    сортировку списка.
    Примечание Ваше решение должно содержать только функции.
    """

    def merge(lst1, lst2):
        result = []
        i, j = 0, 0
        while i < len(lst1) and j < len(lst2):
            if lst1[i] < lst2[j]:
                result.append(lst1[i])
                i += 1
            else:
                result.append(lst2[j])
                j += 1
        result.extend(lst1[i:])
        result.extend(lst2[j:])
        return result

    def merge_sort(lst):
        if len(lst) < 2:
            return lst
        mid = len(lst) // 2
        left = merge_sort(lst[:mid])
        right = merge_sort(lst[mid:])
        return merge(left, right)


def p_4_3_g():
    """
    Во многих задачах требуется контроль входных данных, в частности,
    несмотря на динамическую типизацию, их типов.
    Разработайте декоратор same_type, который производит проверку
    переменного количества позиционных параметров. В случае получения
    не одинаковых типов выводит сообщение "Обнаружены различные
    типы данных" и прерывает выполнение функции.
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    def same_type(func):
        def new_func(*args):
            if len(set(type(a) for a in args)) != 1:
                print("Обнаружены различные типы данных")
                return
            return func(*args)

        return new_func


def p_4_3_h():
    """
    Числа Фибоначчи весьма интересная последовательность и
    используется в различных математических задачах. В ней каждый
    следующий элемент равен сумме двух предыдущих. Математики
    начинают эту последовательность с двух единиц, но мы же с
    вами программисты, поэтому привыкли вести счет с нуля.
    Напишите генератор fibonacci, который последовательно
    возвращает заданное количество чисел Фибоначчи по
    "правилам программистов".
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    def fibonacci(n):
        f1, f2 = 0, 1
        for i in range(n):
            if i in (0, 1):
                yield i
            else:
                num = f1 + f2
                f1, f2 = f2, num
                yield num

    # print(*fibonacci(5))  # 0 1 1 2 3
    # print(*fibonacci(10), sep=", ")  # 0, 1, 1, 2, 3, 5, 8, 13, 21, 34


def p_4_3_i():
    """
    Напишите генератор cycle, который принимает список
    и работает аналогично итератору itertools.cycle.
    Примечание Ваше решение должно содержать только функции.
    В решении не должно быть вызовов требуемых функций.
    """

    def cycle(lst):
        i = -1
        while True:
            i += 1
            yield lst[i % len(lst)]

    # print(*(x for _, x in zip(range(5), cycle([1, 2, 3]))))
    # print("1 2 3 1 2")
    # print(*(x for _, x in zip(range(15), cycle([1, 2, 3, 4]))))
    # print("1 2 3 4 1 2 3 4 1 2 3 4 1 2 3")


def p_4_3_j():
    """
    Весьма часто, данные, которые мы получаем из различных
    источников, не удовлетворяют нашим пожеланиям.
    Одна из частых проблем – излишняя вложенность списков.
    Напишите функцию make_linear, которая принимает список
    списков и возвращает его "выпрямленное" представление.

    Примечание Ваше решение должно содержать только функции.
    """

    def make_linear(lst):
        result = []
        for i in lst:
            if isinstance(i, list):
                result.extend(make_linear(i))
            else:
                result.append(i)
        return result

    # print(make_linear([1, 2, [3]]) == [1, 2, 3])
    # print(make_linear([1, [2, [3, 4]], 5, 6]) == [1, 2, 3, 4, 5, 6])
