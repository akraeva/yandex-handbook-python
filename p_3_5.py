# Yandex / Хендбуки / Основы Python
# 3.5. Потоковый ввод/вывод. Работа с текстовыми файлами. JSON

from sys import stdin
import json
from math import ceil


def p_3_5_a():
    """
    Начнём с простой, но полезной задачи.
    Напишите программу, которая считывает все введённые строки и
    находит сумму всех чисел в потоке ввода.

    Формат ввода Вводятся строки чисел.
    Формат вывода Одно число — сумма всех чисел в потоке ввода.
    """
    # from sys import stdin
    print(sum(sum(map(int, line.split())) for line in stdin))


def p_3_5_b():
    """
    Учитель физкультуры задался вопросом, на сколько в среднем его
    подопечные выросли за прошедший месяц.
    Поможем ему провести вычисления на Python!
    Напишите программу, которая определяет, на сколько изменился
    средний рост учеников в классе.

    Формат ввода Вводится информация о детях в формате:
    <Имя> <Рост месяц назад> <Рост сейчас>
    Формат вывода Одно число — ответ на вопрос задачи.
    Ответ округлите до целых. Например, функцией round.
    """
    # from sys import stdin
    result = [
        h2 - h1 for line in stdin for h1, h2 in [map(int, line.strip().split()[1:])]
    ]
    print(round(sum(result) / len(result)))


def p_3_5_с():
    """
    Как вы помните, когда вы комментируете свой код, перед его выполнением
    интерпретатор удаляет комментарии. Напишите программу, которая выполняет
    эту функцию — удаляет комментарии из кода.

    Формат ввода Вводятся строки программы.
    Формат вывода Каждую строку нужно очистить от комментариев.
    А если комментарий — вся строка, то выводить её не нужно.
    """
    # from sys import stdin
    for line in stdin:
        if "#" in line:
            if line.strip().startswith("#"):
                pass
            else:
                print((line[: line.find("#")].rstrip()))
        else:
            print(line.rstrip("\n"))


def p_3_5_d():
    """
    Поиск информации — важная часть современной жизни.
    Создайте программу, которая реализует маленький компонент поисковой
    системы: она должна находить строки, содержащие заданный запрос.

    Формат ввода Вводятся заголовки страниц.
    В последней строке записан поисковый запрос.
    Формат вывода Вывести все заголовки страниц, в которых присутствует
    поисковый запрос (регистр не имеет значения).
    Порядок заголовков должен сохраниться.
    """
    # from sys import stdin
    lines = stdin.readlines()
    query = lines.pop().strip().lower()
    for line in lines:
        if query in line.lower():
            print(line.rstrip())


def p_3_5_e():
    """
    Мы уже писали программы, которые определяли, палиндром ли перед нами.
    Теперь задача посложнее: найдите все слова-палиндромы среди введённых
    строк и выведите их без повторов, в алфавитном порядке.

    Формат ввода Вводятся слова.
    Формат вывода Список слов-палиндромов в алфавитном порядке без повторений.
    Примечание При проверке слов не обращайте внимание на регистр.
    """
    # from sys import stdin
    print(
        *sorted(
            set(
                word
                for line in stdin.readlines()
                for word in line.strip().split()
                if word.lower() == word.lower()[::-1]
            )
        ),
        sep="\n",
    )


def p_3_5_f():
    """
    Переходим к работе с файлами.
    Для международных документов русский текст преобразуется с
    использованием латинского алфавита. Вам предстоит выполнить
    транслитерацию текста по стандарту ГОСТ.
    Например: ГОСТ Р 52535.1-2006 задаёт правила
    транслитерации идентификационных карт.

    В этой задаче вы впервые будете считывать текст из файла
    и записывать результат в другой файл.
    А ещё — аккуратно работать с символами и строками,
    соблюдая правила преобразования регистра.

    Ниже приведена таблица замен:

    А — A
    Б — B
    В — V
    Г — G
    Д — D
    Е — E
    Ё — E
    Ж — ZH
    З — Z
    И — I
    Й — I
    К — K
    Л — L
    М — M
    Н — N
    О — O
    П — P
    Р — R
    С — S
    Т — T
    У — U
    Ф — F
    Х — KH
    Ц — TC
    Ч — CH
    Ш — SH
    Щ — SHCH
    Ы — Y
    Э — E
    Ю — IU
    Я — IA

    Букву «ё» транслитерируйте как «e», «й» как «и», а «ъ» и «ь»
    (и их заглавные версии «Ъ» и «Ь») должны исчезнуть из текста.
    Строчные буквы заменяются на строчные, заглавные заменяются на заглавные.

    Если заглавная буква превращается при транслитерации в несколько букв,
    то заглавной должна остаться только первая из них (например, «Ц» → «Tc»).
    Все некириллические символы должны остаться на месте.

    Формат ввода В одной папке с вашей программой лежит файл cyrillic.txt.
    В нём, в числе прочих, содержится некоторое количество кириллических
    символов.
    Формат вывода В файл transliteration.txt записать результат
    транслитерации исходного файла.
    """
    translit_dict = {
        "А": "A",
        "Б": "B",
        "В": "V",
        "Г": "G",
        "Д": "D",
        "Е": "E",
        "Ё": "E",
        "Ж": "ZH",
        "З": "Z",
        "И": "I",
        "Й": "I",
        "К": "K",
        "Л": "L",
        "М": "M",
        "Н": "N",
        "О": "O",
        "П": "P",
        "Р": "R",
        "С": "S",
        "Т": "T",
        "У": "U",
        "Ф": "F",
        "Х": "KH",
        "Ц": "TC",
        "Ч": "CH",
        "Ш": "SH",
        "Щ": "SHCH",
        "Ы": "Y",
        "Ь": "",
        "Ъ": "",
        "Э": "E",
        "Ю": "IU",
        "Я": "IA",
    }

    file_in_name, file_out_name = (
        "cyrillic.txt",
        "transliteration.txt",
    )  # <= "data/cyrillic.txt" for tests
    with open(file_in_name, encoding="UTF-8") as file_in, open(
        file_out_name, "w", encoding="UTF-8"
    ) as file_out:
        for line in file_in:
            translit_text = ""
            for ch in line:
                upper_ch = ch.upper()
                if upper_ch in translit_dict:
                    translit = translit_dict[upper_ch]
                    translit_text += (
                        translit.capitalize() if ch.isupper() else translit.lower()
                    )
                else:
                    translit_text += ch
            file_out.write(translit_text)


def p_3_5_g():
    """
    Иногда нужно быстро понять, что содержится в файле с числами:
    сколько их, какие, и каковы основные показатели.
    Напишите программу, которая для заданного файла
    вычисляет следующие параметры:
    - количество всех чисел;
    - количество положительных чисел;
    - минимальное число;
    - максимальное число;
    - сумма всех чисел;
    - среднее арифметическое всех чисел с точностью
      до двух знаков после запятой.

    Формат ввода Пользователь вводит имя файла.
    Файл содержит произвольное количество чисел,
    разделённых пробелами и символами перевода строки.
    Формат вывода Выведите статистику в указанном порядке.
    """
    file_name = input()  # <= "data/numbers.txt" for tests
    with open(file_name, encoding="UTF-8") as file:
        nums = [int(num) for line in file.readlines() for num in line.strip().split()]
    result = (
        len(nums),
        sum(1 for num in nums if num > 0),
        min(nums),
        max(nums),
        sum(nums),
        round(sum(nums) / len(nums), 2),
    )
    print(*result, sep="\n")


def p_3_5_h():
    """
    Иногда нужно понять, чем два текста отличаются. Например,
    какие слова встретились только в одном источнике.
    Напишите программу, которая сравнивает два файла и записывает
    в третий файл все слова, которые есть только в одном из них.

    Формат ввода Пользователь вводит три имени файлов.
    Каждый из входных файлов содержит произвольное количество слов,
    разделённых пробелами и символами перевода строки.
    Формат вывода В третий файл выведите в алфавитном порядке без
    повторений список слов, которые есть только в одном из файлов.
    """

    def words_in_file(file_name):
        with open(file_name, encoding="UTF-8") as file:
            words = set(word for word in file.read().replace("\n", " ").strip().split())
        return words

    # file_1, file_2, file_out = ("data/" + name for name in ("first.txt", "second.txt", "answer.txt")) <= for tests
    file_1, file_2, file_out = (input() for _ in range(3))
    result = sorted(words_in_file(file_1) ^ words_in_file(file_2))
    with open(file_out, "w", encoding="UTF-8") as file:
        print(*result, sep="\n", file=file)


def p_3_5_i():
    """
    Python — отличный инструмент для создания утилит,
    которые обрабатывают текстовые файлы.
    Напишите скрипт, который «почистит» заданный файл от мусора:
    - повторяющихся пробелов;
    - повторяющихся символов перевода строки;
    - табуляций;
    - излишних пробелов в начале и конце строк.

    Формат ввода Пользователь вводит два имени файлов.
    Входной файл содержит неформатированный текст произвольной длины.
    Формат вывода Во второй файл выведите очищенный текст.
    """
    # file_in, file_out = ("data/" + name for name in ("first1.txt", "second1.txt")) <= for tests
    file_in, file_out = (input() for _ in range(2))
    with open(file_in, encoding="UTF-8") as file, open(
        file_out, "w", encoding="UTF-8"
    ) as result:
        for line in file:
            text = line.strip()
            if text:
                if "\t" in text:
                    text = text.replace("\t", "")
                while "  " in text:
                    text = text.replace("  ", " ")
                while "\n\n" in text:
                    text = text.replace("\n\n", "\n")
                result.write(text + "\n")


def p_3_5_j():
    """
    В Linux есть удобная команда tail, которая показывает последние
    строки файла — особенно полезно, если файл большой.
    Напишите аналог этой утилиты: программа должна выводить
    последние N строк из заданного файла.

    Формат ввода Пользователь вводит имя файла (F), а затем
    количество строк (N), которые он хочет увидеть.
    Формат вывода Выведите N последних строк файла F.
    """
    file_name = input()  # "data/some_file.txt" <= for tests
    n_lines = int(input())
    with open(file_name, encoding="UTF-8") as file:
        lines = file.readlines()
    print(*(line.strip() for line in lines[len(lines) - n_lines :]), sep="\n")


def p_3_5_k():
    """
    Иногда нужно не просто посчитать статистику по файлу, но и сохранить её
    в универсальном формате для других программ.
    Напишите программу, которая вычисляет ключевые числовые параметры
    и сохраняет их в файл в формате JSON:
    - количество всех чисел;
    - количество положительных чисел;
    - минимальное число;
    - максимальное число;
    - сумма всех чисел;
    - среднее арифметическое всех чисел с точностью до двух
       знаков после запятой.

    Формат ввода Пользователь вводит два имени файла.
    Первый файл содержит произвольное количество чисел, разделённых
    пробелами и символами перевода строки.
    Формат вывода Выведите статистику во второй файл в формате JSON.

    Ключи значений задайте соответственно:
    count — количество всех чисел;
    positive_count — количество положительных чисел;
    min — минимальное число;
    max — максимальное число;
    sum — сумма всех чисел;
    average — среднее арифметическое всех чисел
    с точностью до двух знаков после запятой.
    """
    # import json

    file_in, fine_out = input(), input()
    # <= "data/numbers.txt", "data/statistics.json" for tests

    with open(file_in, encoding="UTF-8") as file:
        nums = list(map(int, file.read().split()))
    result = {
        "count": len(nums),
        "positive_count": sum(1 for num in nums if num > 0),
        "min": min(nums),
        "max": max(nums),
        "sum": sum(nums),
        "average": round(sum(nums) / len(nums), 2),
    }
    with open(fine_out, "w", encoding="UTF-8") as file:
        json.dump(result, file, ensure_ascii=False, indent=4)


def p_3_5_l():
    """
    Числа можно классифицировать по-разному.
    Например, по количеству чётных и нечётных цифр.
    Напишите программу, которая делит числа из файла
    на три группы и записывает каждую в отдельный файл.
    - числа с преобладающим количеством чётных цифр;
    - числа с преобладающим количеством нечётных цифр;
    - числа с одинаковым количеством чётных и нечётных цифр.

    Формат ввода Пользователь вводит четыре имени файла.
    Первый файл содержит произвольное количество чисел,
    разделённых пробелами и символами перевода строки.
    Формат вывода В три другие файла выведите числа,
    которые подходят под требуемое условие.
    Сохраните положение чисел в строках.
    """

    def which_type(num):
        even = len(list(filter(lambda x: int(x) % 2 == 0, num)))
        odd = len(num) - even
        if even == odd:
            return "eql"
        if even > odd:
            return "even"
        else:
            return "odd"

    # file_in, file_even, file_odd, file_eql = ("data/" + name for name in ("numbers1.txt", "even.txt", " odd.txt", "eq.txt"))
    file_in, file_even, file_odd, file_eql = (input() for _ in range(4))
    with open(file_in, encoding="UTF-8") as f, open(
        file_even, "w", encoding="UTF-8"
    ) as fe, open(file_odd, "w", encoding="UTF-8") as fo, open(
        file_eql, "w", encoding="UTF-8"
    ) as fq:
        files = {"even": fe, "odd": fo, "eql": fq}
        for line in f:
            result = {"even": [], "odd": [], "eql": []}
            for num in line.strip().split():
                result[which_type(num)].append(num)
            for name in files:
                files[name].write(" ".join(result[name]) + "\n")


def p_3_5_m():
    """
    Часто приходится обновлять данные.
    Создайте программу, которая обновляет JSON файл.

    Формат ввода Пользователь вводит имя файла.
    Затем вводятся строки вида ключ == значение.
    Формат вывода В заданный пользователем файл
    следует записать обновленный JSON.
    """
    # import json
    # from sys import stdin

    file_name = input()  # data/data.json <= for tests
    with open(file_name, encoding="UTF-8") as file:
        data = json.load(file)
    for line in stdin.readlines():
        key, value = line.strip().split(" == ")
        data[key] = value
    with open(file_name, "w", encoding="UTF-8") as file:
        json.dump(data, file, ensure_ascii=False, indent=4)


def p_3_5_n():
    """
    Местная компания решила обновить и одновременно перестроить
    свою систему хранения пользовательских данных.
    Напишите программу, которая принимает два JSON-файла:
    с текущими данными и обновлениями, а затем объединяет их в новую структуру.

    Формат ввода Пользователь вводит два имени файла.
    В первом хранится JSON массив пользователей.
    Во втором — массив новых данных.

    Информация о каждом пользователе представляется JSON объектом,
    в котором обязательно присутствует поле name, описывающее имя пользователя.
    Остальные поля являются дополнительными.
    Формат вывода В первый файл запишите информацию о пользователях в виде
    JSON объекта, ключами которого выступают имена пользователей,
    а значениями — объекты с информацией о них.

    Если какая-либо дополнительная информация о пользователе изменяется,
    то требуется сохранить лексикографически большее значение.
    """
    # import json
    file_users, file_update = (
        input(),
        input(),
    )  # data/users.json", "data/updates.json"  <= for tests

    with open(file_users, encoding="UTF-8") as file:
        records = json.load(file)
    data = {}
    for row in records:
        data[row["name"]] = {key: value for key, value in row.items() if key != "name"}
    with open(file_update, encoding="UTF-8") as file:
        records = json.load(file)
    for row in records:
        name = row["name"]
        for key, value in row.items():
            if key != "name":
                if key not in data[name].keys() or value > data[name][key]:
                    data[name][key] = value
    with open(file_users, "w", encoding="UTF-8") as file:
        json.dump(data, file, indent=4)


def p_3_5_o():
    """
    Сегодня вы — Ядекс.Контест.
    Напишите программу, которая рассчитывает итоговый балл за выполнение
    задания на основе файла с тестами и входного потока с ответами.
    Вашему решению доступен файл scoring.json, в котором содержится
    информация о системе проверки.

    Основой системы является список групп тестов.
    Каждая группа представляет собой объект с полями:
    points — количество очков, которое можно получить
             за прохождение данной группы;
    tests — список объектов с описанием конкретного теста.

    Объект описывающий тест содержит поля:
    input — строка входных данных теста;
    pattern — строка ожидаемых в качестве ответа.
    В стандартный поток ввода вашего решения передаются ответы,
    полученные от тестируемой программы.

    Формат ввода В стандартный поток ввода передаются строки —
    ответы тестируемой программы на каждый тест.
    В файле scoring.json содержится информация о тестах задачи.
    Формат вывода Одно число — количество полученных тестируемой
    программой баллов. Если группа тестов не была пройдена полностью,
    то за данную группу ставится пропорциональный балл.
    Гарантируется, что баллы за группу кратны количеству тестов в ней.
    """
    # from sys import stdin
    # import json
    result = 0
    answers = list(map(str.strip, stdin.readlines()))
    with open("data/scoring.json", encoding="UTF-8") as file:
        test_groups = json.load(file)
    for group in test_groups:
        points = group["points"]
        tests = group["tests"]
        count = len(tests)
        result += sum(
            points // count if answer == qestion["pattern"] else 0
            for answer, qestion in zip(answers, tests)
        )
        answers = answers[count:]
    print(result)


def p_3_5_p():
    """
    А теперь давайте вновь напишем компонент поисковой системы —
    на этот раз с учётом формата и содержимого файлов.
    Сначала вводится поисковый запрос. Затем — список файлов,
    в которых нужно искать. Нужно найти, в каких файлах встречается запрос,
    без учёта регистра и с учётом любых пробелов и переводов
    строки как обычных пробелов.

    Формат ввода Сначала вводится поисковый запрос.
    Затем вводятся имена файлов, среди которых следует произвести поиск.
    Формат вывода Выведите все имена файлов, в которых есть поисковая
    строка без учета регистра и повторяющихся пробельных символов.
    Если ни в одном файле информация не была найдена, выведите 404. Not Found.
    Примечание Система поиска должна обрабатывать строки
      "a&nbsp;&nbsp;&nbsp;&nbsp;b", "a b" и "a\nb" как одинаковые.
    """
    # from sys import stdin
    query = " ".join(input().lower().strip().split())
    result = []
    for file_name in stdin.readlines():
        with open(file_name.strip(), encoding="UTF-8") as file:
            data = " ".join(
                word.strip() for line in file for word in line.strip().lower().split()
            )
            if query in data:
                result.append(file_name.strip())
    print("\n".join(result) if result else "404. Not Found")


def p_3_5_q():
    """
    Нам дали зашифрованный файл, и сказали, что нужно «выдернуть» младший
    байт из каждого символа — так восстанавливается спрятанное сообщение.

    Справка:
    Стеганография — способ передачи или хранения информации с учётом
    сохранения в тайне самого факта такой передачи (хранения).
    В отличие от криптографии, которая скрывает содержимое тайного сообщения,
    стеганография скрывает сам факт его существования. Как правило,
    сообщение будет выглядеть как что-либо иное, например, как изображение,
    статья, список покупок, письмо или судоку. Стеганографию обычно используют
    совместно с методами криптографии, таким образом, дополняя её.

    Нам был дан файл со скрытым текстом. И было сообщено, что для выделения
    полезной информации, нужно из каждого кода символа в тексте «выдернуть»
    младший байт. Это и будет код символа полезной информации.
    Однако есть одно «но». Если код символа меньше 128 — это и есть
    полезная информация. Разработайте программу, которая из текстового файла
    выделяет полезную информацию.

    Формат ввода В файле secret.txt хранится текст.
    Формат вывода Выведите спрятанное сообщение.

    """
    file_name = "secret.txt"  # "data/secret.txt" <= for tests
    with open(file_name, encoding="UTF-8") as file:
        print(
            "".join(
                ch if ord(ch) < 128 else chr(ord(ch) % 128)
                for line in file
                for ch in line
            )
        )


def p_3_5_r():
    """
    Финиш близко — всего две задачи!
    Перед этим — лёгкая утилита: нужно определить размер файла и
    отформатировать его по ГОСТу. Это пригодится для работы с логами,
    архивами или системными файлами.
    В нашей странице согласно ГОСТ 8.417-2002 объём информации
    измеряется в следующих единицах:
    - бит (б)
    - Байт (Б) = 8 бит
    - Килобайт (КБ) = 1024 Б
    - Мегабайт (МБ) = 1024 КБ
    - Гигабайт (ГБ) = 1024 МБ
    Напишите программу, которая вычисляет объём заданного файла.

    Формат ввода Вводится одно имя файла.
    Формат вывода Выведите объём файла в соответствующих единицах измерения.
    При получении дробного значения, произведите округление вверх.
    """

    # from math import ceil
    def choice_of_units(size):
        units = ["б", "Б", "КБ", "МБ", "ГБ"]
        n = 0
        if size < 1:
            size *= 8
        else:
            n += 1
            while size >= 1024 or n == 4:
                size = size / 1024
                n += 1
        return f"{ceil(size)}{units[n]}"

    file_name = input()  # "data/file.txt", "data/another_file.txt" <= for tests
    with open(file_name, "rb") as file:
        file.seek(0, 2)
        size = file.tell()

    print(choice_of_units(size))


def p_3_5_s():
    """
    Давайте реализуем шифр Цезаря, который сдвигает латинские буквы по кругу.
    Работать будем с текстом в файле — это приближает задачу к реальным
    случаям шифрования данных. Шифр Цезаря, также известный как шифр сдвига,
    код Цезаря — один из самых простых и наиболее широко известных методов
    шифрования. Он назван в честь римского полководца Гая Юлия Цезаря,
    использовавшего его для секретной переписки со своими генералами.
    Давайте реализуем эту систему шифрования. Однако для простоты мы будем
    сдвигать только латинские символы по кругу.

    Формат ввода Вводится размер сдвига для шифрования.
    В файле public.txt содержится текст на английском языке.
    Формат вывода В файл private.txt запишите зашифрованный текст.
    """

    def encrypted(ch, shift):
        if ord(ch.lower()) in range(ord("a"), ord("z") + 1):
            start = ord("a") if ch.islower() else ord("A")
            return chr((ord(ch) - start + shift) % 26 + start)
        return ch

    # 'data/public.txt', 'data/private.txt' <= for tests
    file_in, file_out = "public.txt", "private.txt"
    shift = int(input())

    with open(file_in, encoding="UTF-8") as text, open(
        file_out, "w", encoding="UTF-8"
    ) as result:
        for line in text:
            result.write("".join(encrypted(ch, shift) for ch in line))


def p_3_5_t():
    """
    Завершим на высокой ноте — вы вычислите сумму чисел в бинарном файле,
    представленных 2-байтными значениями. Вы скорее всего знаете, что
    существуют не только текстовые файлы. Различные форматы данных
    предусматривают специальное кодирование. Например, BMP изображения хранят
    некоторую заголовочную информацию и цвета всех пикселей в виде чисел.

    Давайте поработаем с такими данными. Нам дают файл в некотором формате,
    назовем его NUM. Он содержит список 2-байтных чисел. Для простоты будем
    считать, что отрицательных чисел не существует. Напишите программу,
    которая вычисляет сумму всех записанных в файле чисел
    в 2-байтном диапазоне.

    Формат ввода В файле numbers.num содержатся числа в указанном формате.
    Формат вывода Одно число — сумма всех чисел в файле на 2-байтном диапазоне.
    Примечание Для простоты файлы в примерах записаны в HEX формате.
    В этом виде файл представляется как последовательность четырехзначных
    шестнадцатеричных чисел.

    В первом примере записано 5 шестнадцатеричных чисел: 1, 2, 3, 4, 5.
    Их сумма равна 15. Во втором — 255 и 257. Их сумма равна 512.

    Файл из примеров в изначальном виде можно загрузить здесь:
    Первый пример
    Второй пример
    Если вы хотите изучить принцип хранения целых чисел в ЭВМ,
    советуем почитать про прямой, обратный и дополнительный коды.
    """
    file_name = "data/sample02.num"  # "data/sample01.num", "data/sample02.num" для тестов "numbers.num"

    acc = 0
    with open(file_name, "rb") as file:
        while num := file.read(2):
            if len(num) < 2:
                break
            acc += int.from_bytes(num)
    print(acc % 0x10000)  # "в 2-байтном диапазоне"!!!
    # нагуглила "% 0x10000" после 100500 неудачно попытки пройти Тест 3, потому что
    # относила эту фразу к числам, а не к результату. ChatGPT-5 не смог это найти.
